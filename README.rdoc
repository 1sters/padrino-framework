= Padrino (padrino-core)

Padrino is the godfather of Sinatra.

== Preface

Padrino is a ruby framework build upon the {Sinatra Microframework}[http://www.sinatrarb.com].

Sinatra is a DSL for quickly creating web applications in Ruby with minimal effort.
  
The extreme simplicity of this framework is quite refreshing. We have been using Sinatra a great deal
for recent projects. First for small and simple json and xml web services and then even
for more complex full-featured applications. 

This gem represents an attempt to make it as fun and easy as possible to code increasingly advanced web applications in Sinatra.

== Introduction

Many people love Sinatra's simplicity and lightweight but often quickly come to miss a great deal
of functionality provided by other web frameworks such as Rails when building non-trivial applications.

The obvious question in these cases might be "Why not just use rails then?". This can often be a viable option
but still Rails is quite a large framework with a 'take it or leave it' attitude.

Personally, we have come to love the philosophy of Sinatra which acts as a thin layer on top of rack 
often allowing middleware to do most of the work and pulling in additional complexity only when required. 

Our goal with this framework is to match the essence of Sinatra and at the same time create a standard library
of tools, helpers and components that will make Sinatra suitable for more complex applications.

Here is a small list of what Padrino provides:

Generators:: for creating new padrino applications i.e.: <tt>padrino-gen app</tt> or <tt>padrino start</tt> on command line
MultiApp:: unlike other ruby frameworks Padrino is principally designed for mounting multiple apps at the same time.
Routing:: Full url named route, named params, respond_to suppor
Tag Helpers:: helpers such as: <tt>tag</tt>, <tt>content_tag</tt>, <tt>input_tag</tt>, ...
Asset Helpers:: helpers such as: <tt>link_to</tt>, <tt>image_tag</tt>, <tt>javascript_include_tag</tt>, ...
Form Helpers:: with builder support such as: <tt>form_tag</tt>, <tt>form_for</tt>, <tt>field_set_tag</tt>, <tt>text_field</tt>, ...
Text Helpers:: useful formatting extensions like: <tt>relative_time_ago</tt>, <tt>js_escape_html</tt>, <tt>sanitize_html</tt>
Mailer:: fast, tiny, delivery support for send templating emails (like ActionMailer do)
Admin:: an ajax admin that displays your records in sortable grids, tree, windows ... as a desktop app can do.
Logging:: Padrino provide a logger that can interact with your orm or any other library
Reloading:: With padrino is not necessary like other framework start and restart your server for see changes.
I18n:: Padrino has a full support of I18n and can autoset locale.

Keep in mind, the user will be able to pull in these components seperately and leave out those that are not required
or use them altogether for a comprehensive upgrade to Sinatra (a full-stack Padrino application).

Note that all work has been created to be compatible with haml, erb, and erubis and that this gem is intended to be 
template-agnostic in providing helpers wherever possible.

Please help me brainstorm and fork the project if you have any ideas to contribute.

== Installation

To install the padrino framework, simply grab the latest version from gemcutter:

  $ sudo gem install padrino --source http://gemcutter.org
  
This will install the necessary padrino gems to get you started.
Now you are ready to use this gem to enhance your sinatra projects or to create new Padrino applications.

== Usage

Padrino is a framework which builds on the existing functionality and Sinatra and provides a variety of 
additional tools and helpers to extend the foundation. This README and Padrino documentation in general will focus
on the enhancements to the core Sinatra functionality. To use Padrino, one should be familiar with the basic 
usage of Sinatra itself. Resources for Sinatra are listed below:

* {Sinatra Introduction}[http://www.sinatrarb.com/intro.html]
* {Sinatra Book}[http://www.sinatrarb.com/book.html]
* {Sinatra Github Repo}[http://github.com/sinatra/sinatra]

Below is a guide to how this gem enhances the Sinatra framework as part of a 'full-stack' padrino application.
For information on how to use a specific gem in isolation within an existing Sinatra project, checkout the README for that 
individual gem or gems.

== Enhanced Base Application (padrino-core)

Sinatra has support for classes which can be extended to create an application: <tt>Sinatra::Base</tt> and <tt>Sinatra::Application</tt>
These classes can be extended in order to create a Sinatra web application. These classes provide support for all the basic
functionality afforded by Sinatra.

Padrino has support for an enhanced base application class <tt>Padrino::Application</tt>. <tt>Padrino::Application</tt>
expands the capabilities of Sinatra::Application and automatically provides the resulting application access to all of
the padrino framework's functionalities. 

Similar in spirit to Sinatra itself, Padrino application layout is extremely flexible and can be as small as a single file.
However, Padrino provides many extensions which improve upon the ability to construct more complex applications.

=== Simple Application Definition

Let us first take a look at the simplest possible Padrino application:

  # app.rb
  PADRINO_ROOT = File.dirname(__FILE__) unless defined? PADRINO_ROOT
  require 'padrino'
  Padrino.load!

  class SimpleApp < Padrino::Application
    get '/' do
      'Hello world'
    end
    
    # and for read better we can divide with controllers
    controller '/admin' do
      get '/foo' do
        'Im /admin/foo
      end
    end
  end

=== Controllers

Suppose we wanted to add additional routes to our Padrino application, and we want to organize the routes
within a more structured layout. Simply add a <tt>controllers</tt> or <tt>app/controllers</tt> folder and create a file as such:

  # Simple Example
  SimpleApp.controllers do
    get "/test" do
      "Text to return"
    end
  end

== Advanced Routing Support

Padrino provides support for advanced routing functionality not available within Sinatra. This routing
supports named route aliases and easy access to url paths. The benefits of this is that instead of having to 
hard-code route urls into every area of your application, now we can just define the urls in a 
single spot and then attach an alias which can be used to refer to the url throughout the application.

=== Padrino Routing

Urls mapped here can then be defined within a controller:

  # app/controllers/example.rb
  SimpleApp.controllers do
    get :index do
      ...
    end

    get :account do
      # access params[:name] and params[:index]
    end
  end

and finally referenced anywhere in the application:

  # app/views/example.haml
  = link_to "Index", url_for(:index)
  = link_to "Account", url_for(:account, :id => 1, :name => 'first')

=== Inline Route Alias Definitions

The routing plugin also supports inline route definitions in which the url and the named alias
are defined together within the controller:

  # app/controllers/example.rb
  SimpleApp.controllers do
    get :index, :map => '/index' do
      ...
    end

    get :account, :map => '/the/accounts/:name/and/:id' do
      # access params[:name] and params[:index]
    end
  end

Routes defined inline this way can be accessed and treated the same way as traditional named aliases.

=== Namespaced Route Aliases

There is also support for namespaced routes which are organized into a larger grouping:

  # app/controllers/example.rb
  SimpleApp.controllers :admin do
    get :show do
      "Im /admin/show"
    end

    get :index, :map => "/admin/:id" do
      "Im /admin/#{params[:id]}"
    end
  end

You can then reference the urls using the same url_for method: 

  <%= link_to 'admin show page', url_for(:admin_show, :id => 25) %>
  <%= link_to 'admin index page', url_for(:admin_index, :id => 25) %>

If you don't want named routes you can

  # app/controllers/example.rb
  SimpleApp.controllers "/admin" do
    get "/show" do
      "Im /admin/show"
    end

    get "other/:id" do
      "Im /admin/#{params[:id]}"
    end
  end

=== Named Params

With Padrino you can use named params!! See these examples

  # app/controllers/example.rb
  SimpleApp.controllers :admin do
    get :show, :with => :id do
      "Im /admin/show/#{params[:id]}"
    end

    get :other, with => [:id, :name]  do
      "Im /admin/#{params[:id]}/#{params[:name]}"
    end
  end

You can then reference the urls using the same url_for method: 

  <%= link_to 'admin show page', url_for(:admin_show, :id => 25) %>
  <%= link_to 'admin other page', url_for(:admin_index, :id => 25, :name => :foo) %>

=== Respond To

With Padrino you can simply respond to a given format see example:

  # app/controllers/example.rb
  SimpleApp.controllers :admin do
    get :show, :with => :id, :respond_to => :js do
      "Im /admin/show/#{params[:id]}.#{params[:format]}"
    end

    get :other, with => [:id, :name], respond_to => [:html, :json] do
      case content_type
        when :js    then ... end
        when :json  then ... end
      end
    end
  end

  <%= link_to 'admin show page', url_for(:admin_show, :id => 25, :format => :js) %>
  <%= link_to 'admin other page', url_for(:admin_index, :id => 25, :name => :foo) %>
  <%= link_to 'admin other json page', url_for(:admin_index, :id => 25, :name => :foo, :format => :json) %>

=== Rendering

Unlike Sinatra Padrino support template auto lookup so:

  # look for 'account/index.{erb,haml,...}
  render 'account/index'

=== Layout

With Padrino you can (like rails do) use for your custom layout, disable it

  class SimpleApp < Padrino::Application
    
    # Disable layouts
    disable layout
    
    # Use the layout located in views/layouts/custom.haml
    layout :custom

=== Gemfile Dependency Resolution
  
While this is a fully operational Padrino application in itself, let us take a look at Padrino's expanded capabilites. First, 
we can create Gemfile within the application root. This will contain a list of all the dependencies for our application.

  # /Gemfile
  clear_sources
  source 'http://gemcutter.org'
  gem 'sinatra',     :require_as => 'sinatra/base'
  gem 'rack-flash'
  
This manifest file uses the standard <tt>bundler</tt> gem syntax of which details can be found in the
{Bundler README}[http://github.com/wycats/bundler]
This gem allows us to place all our dependencies into a single file. Padrino will then automatically require
all necessary files (if they exist on the system). 

If the dependencies are not on the system, you can automatically vendor all necessary gems 
using the <tt>gem bundle</tt> command within the application root. Note that this is all possible without
any further effort than adding the Gemfile (or having this generated automatically with generators explained later).

=== Auto Load Paths

Padrino also intelligently supports requiring useful files within your application automatically and provides
functionality for easily splitting up your application into separate files. Padrino automatically requires <tt>config/database.rb</tt>
as a convention for establishing database connection. Also, any files within the <tt>lib</tt> folder will be required 
automatically by Padrino.

This is powered by the fact that Padrino will automatically load (and reload) any directory patterns within the 'load path'. 
Additional directory patterns can be added to the load path as needed by simply appending to the <tt>load_paths</tt> 
within your application:

  # app.rb
  class SimpleApp < Padrino::Application
    load_paths << ["app/special/*.rb", "some_file.rb"]
  end
  
This will instruct Padrino to autoload these files (and reload them when changes are detected). By default, the load path 
contains certain paths known to contain important files such as controllers, mailers, models, urls, and helpers. 

=== Initializers

Padrino also has support for 'initializers' which are important setup steps or configuration within an application
that should occur during the bootup process. To construct initializers, simply add a file to the <tt>config/initializers<tt>
directory following this convention:

  # config/initializers/example.rb
  module ExampleInitializer
    def self.registered(app)
      # Manipulate 'app' here to register components or adjust configuration
      app.set :environment, :production # just an example configuration change
      app.use Hassle # or even enable middleware
    end
  end
  
Initializers are automatically required and 'registered' during the application startup process. Note that
the name of the module must be the name of the file appended with 'Initializer' (i.e sample.rb => SampleInitializer)

=== Application Logging

Padrino also supports robust logging capabilities. By default, logging information will
go to the STDOUT in development (for use in a console) and in an environment-specific log file <tt>log/development.log</tt>
in test and production environments.

You can modify the logging behavior or disable logging altogether:

  # app.rb
  class SimpleApp < Padrino::Application
    disable :logging     # Turns off logging
    enable  :log_to_file # Forces logging to be written to a file
  end
  
To use the logger within a Padrino application, simply refer to the <tt>logger</tt> method accessible
within your app and any controller or views:

  # controllers/example.rb
  SimpleApp.controllers do
    get("/test") { logger.info "This is a test" }
  end
  
The logger automatically supports severity through the use of <tt>logger.info</tt>, <tt>logger.warn</tt>, <tt>logger.error</tt>, et al.
For more information about the logger, check out the {Logger RDOC}[http://www.ruby-doc.org/stdlib/libdoc/logger/rdoc/]

=== Mounting Applications

Padrino applications are all automatically mountable into other Padrino projects. This means that a given Padrino
project directory can easily mount multiple applications. This allows for better organization of complex applications,
re-usable applications that can be applied (i.e admin, auth, blog) and even more flexibility. 

You can think of mountable applications as a 'full-featured' merb slice or rails engine. Instead of a separate construct, 
any application can simply be packaged and mounted into another project.

Padrino stores application mounting information by default within <tt>config/apps.rb</tt>. This file is intended
to keep all information regarding what applications are mounted to which uri's. An <tt>apps.rb</tt> file has
the following structure:

  Padrino.mount("blog").to("/blog")
  Padrino.mount("website").to("/website")
  
This would mount two applications onto the Padrino project, one served from the '/blog' uri namespace and the other
served from the '/website' uri namespace. Often a Padrino project directory requires a single 'core' application
which is served from the uri root. This can be easily configured using:

  Padrino.mount_core("app_name") # mounts app with class AppName, in file <tt>app/app.rb</tt>
  Padrino.mount_core("app_name", :app_file => Padrino.root('app.rb')) # now with file in <tt>app.rb</tt>
  
This will mount a 'core' application with class AppName from the file 'app.rb' to the uri root which will
act as a primary application.

=== Development Reloader

Padrino applications also have the enabled ability to automatically reload all changing application files without
the need to restart the server. Through the use of a customized Rack middleware, all files on the 'load path'
are monitored and reloaded whenever changes are applied. 

This makes rapid development much easier and provides a better alternative to 'shotgun' or 'rerun' 
which require the application server to be restarted which makes requests take much longer to complete.

An application can explicitly enable / disable reloading through the use of options:

  # app.rb
  class SimpleApp < Padrino::Application
    disable :reload # reload is disabled in all environments
    enable  :reload # enabled in all environments
  end
  
By default, reloading is enabled in development and disabled in the test and production environments.

If you want to build a standalone app you need to take some precautions see example:

  # simple_demo.rb
  PADRINO_ROOT = File.dirname(__FILE__) unless defined? PADRINO_ROOT
  require 'padrino-core'

  class SimpleDemo < Padrino::Application
    set :reload, true

    get "/" do
      "This is a simple Demo!!!"
    end
  end

  Padrino.mount_core("SimpleDemo")

  Padrino.run! unless Padrino.loaded? # If you enable reloader prevent to re-run the app 

  Padrino.load!

Now you can run simple_demo.rb with:

  $ ruby simple_demo.rb

Browse http://localhost:3000 edit your file and refresh your page for see changes!

=== Terminal Commands

Padrino also comes equipped with multiple useful terminal commands which can be activated to perform
common tasks such as starting / stopping the application, executing the unit tests or activating an irb session.

The following commands are available:

  # starts the app server (non-daemonized)
  $ padrino start 
  # starts the app server (daemonized) with given port, environment and adapter
  $ padrino start -d -p 3000 -e development -a thin 
  
  # Stops a daemonized app server
  $ padrino stop
  
  # Run all the unit tests
  $ padrino test
  
  # Bootup the Padrino console (irb)
  $ padrino console
  
  # Run/List tasks
  $ padrino rake

Using these commands can simplify common tasks making development that much smoother.

=== Special Folders

Padrino load these paths:

  project/lib
  project/models
  project/shared/lib
  project/shared/models
  project/each_app/models

This mean that you are free to store for example +models+ where you prefer, if you have two or more apps with same
models you can use +project/shared/models+ or +root/models+.

If you have only one app you still use +project/app/models+ (this is the default padrino-gen choice)

Remember that if you need to load other paths you can use:

  Padrino.set_load_paths("path/one")

and if you need to load dependencies use:

  Padrino.require_dependencies("path/one/**/*.rb")

= Agnostic Application Generators (padrino-gen)

=== Overview

Padrino comes preloaded with flexible code generators powered in part by the excellent Thor gem
(incidentally also used in the Rails 3 generators). These generators are intended to allow for easy code generation
both in creating new applications and building on existing ones. The generators have been built to be as library agnostic
as possible, supporting a myriad of test frameworks, js libraries, mocking libraries, etc.

See the wiki article for additional information: <...WIKI...>

=== Application Generator

Padrino provides generator support for quickly creating new Padrino applications. This provides many benefits
such as constructing the recommended Padrino application structure, auto-generating a Gemfile listing
all starting dependencies and guidelines provided within the generated files to help orient a new user
to using Padrino.

One important feature of the generators is that they were built from the ground up to support a wide variety
of tools, libraries and gems for use within your padrino application. 

This means that Padrino generators do *not* lock you into using any particular database, ORM, testing framework, 
templating engine or javascript library. In fact, when generating an application you can actually tell 
Padrino which components you would like to use!

The usage for the app generator is quite simple:

  $ padrino-gen app <the_app_name> </path/to/create/app> --<component-name> <value>

The simplest possible command to generate a base application would be:

  $ padrino-gen demo_app .
  
This would construct a Padrino application DemoApp (which extends from Padrino::Application) 
inside the folder 'demo_app' at our current path. Inside the application there would be configuration and 
setup performed for the default components.

You can also define specific components to be used:

  $ padrino-gen demo_app . --test rspec --renderer haml --mock rr --script jquery --orm datamapper
  
There is also support for aliases for each component within the command:

  $ padrino-gen demo_app . -t rspec -r haml -m rr -s jquery -d datamapper
  
You can also instruct the generator to skip a certain component to avoid using one at all (or to use your own):

  $ padrino-gen demo_app . --test none --renderer none
  
The available components and their default options are listed below:

* test:     <tt>bacon</tt>  (default), <tt>shoulda</tt>, <tt>rspec</tt>, <tt>testspec</tt>, <tt>riot</tt>
* renderer: <tt>erb</tt>    (default), <tt>haml</tt>
* mock:     <tt>mocha</tt>  (default), <tt>rr</tt>
* script:   <tt>jquery</tt> (default), <tt>prototype</tt>, <tt>rightjs</tt>
* orm:      <tt>datamapper</tt> (default), <tt>mongomapper</tt>, <tt>activerecord</tt>, <tt>sequel</tt>, <tt>couchrest</tt>

The generator uses the <tt>bundler</tt> gem to resolve any application dependencies when the application is newly created.
The necessary bundler command can be executed automatically through the generator with

  $ padrino-gen demo_app . --run_bundler # alias -b

or this can be done manually through executing command <tt>gem bundle</tt> in the terminal at the root of the generated application.
If not executed manually, the bundling will be performed automatically the first time the application attempts to boot.
Note that this command only has to be performed when the application is first generated or when the Gemfile is modified.
 
The generator framework within padrino is extensible and additional components and tools can be added easily.
This would be achieved through forking our project and reading through the code in <tt>lib/generators/App.rb</tt> and
the setup instructions inside the relevant files within <tt>lib/generators/components/</tt>. We are happy to accept pull requests
for additional component types not originally included (although helping us maintain them would also be appreciated).

=== Model Generator

Padrino provides generator support for quickly creating new models within your Padrino application. Note that
the models (and migrations) generated are specifically tailored towards the ORM component and testing framework
chosen during application generation. 

Very important to note that model generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. Using model generators 
within an existing application not generated by Padrino will likely not work as expected.

Using the model generator is as simple as:

  $ padrino-gen model User
  
You can also specify desired fields to be contained within your User model:

  $ padrino-gen model User name:string age:integer email:string
  
The model generator will create multiple files within your application and based on your ORM component. 
Usually the model file will generate files similar to the following:

  * model definition file [app/models/user.rb]
  * migration declaration [db/migrate/xxx_create_users.rb]
  * model unit test file  [test/models/user_test.rb]
  
You can define as many models as you would like in a Padrino application using this generator.

You can destroy models that you created via the destroy option and setting it to true. default is false.
  
  $ padrino-gen model User -d
  
This remove all created model files.

=== Migration Generator

Padrino provides generator for quickly generating new migrations to change or manipulate the database schema.
These migrations generated will be tailored towards the ORM chosen when generating the application.

Very important to note that migration generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. Using migration generators 
within an existing application not generated by Padrino will likely not work as expected.

Using the migration generator is as simple as:

  $ padrino-gen migration AddFieldsToUsers
  $ padrino-gen migration RemoveFieldsFromUsers
  
You can also specify desired columns to be added to the migration file:

  $ padrino-gen migration AddFieldsToUsers last_login:datetime crypted_password:string
  $ padrino-gen migration RemoveFieldsFromUsers password:string ip_address:string
  
The migration generator will then construct the migration file according to your ORM component chosen
within <tt>db/migrate/xxx_add_fields_to_users.rb</tt> including the columns specified in the command.

You can destroy migrations that you created via the destroy option and setting it to true. default is false.
  
  $ padrino-gen migration AddFieldsToUsers -d
  
This removes the migration file.

=== Controller Generator

Padrino provides generator support for quickly creating new controllers within your Padrino application. Note that
the controller tests are generated specifically tailored towards the testing framework chosen 
during application generation. 

Very important to note that controller generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. 

Using the controller generator is as simple as:

  $ padrino-gen controller Admin
  
You can also specify desired actions to be added to your controller:

  $ padrino-gen controller Admin get:index get:new post:create
  
The controller generator will then construct the controller file within <tt>app/controllers/admin.rb</tt>
and also a controller test file at <tt>test/controllers/admin_controller_test.rb</tt> according to the 
test framework chosen during app generation. A default route will also be generated mapping to name of the controller and the route name. For example:

  $ padrino-gen controller User get:index
  
  will create a url route for :index mapping to "/user/index"
  
You can destroy controllers that you created via the destroy option and setting it to true. default is false.

    $ padrino-gen controller User -d

This removes all created controller files.

=== Mailer Generator

Padrino provides generator support for quickly creating new mailers within your Padrino application.
Very important to note that mailer generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. 

Using the mailer generator is as simple as:

  $ padrino-gen mailer UserNotifier
  
You can also specify desired delivery actions to be added to the mailer:

  $ padrino-gen mailer UserNotifier confirm_account welcome inactive_account
  
The mailer generator will then construct the mailer file within <tt>app/mailers/user_notifier.rb</tt>

You can destroy mailer that you created via the destroy option and setting it to true. default is false.
  
  $ padrino-gen mailer UserNotifer -d
  
This remove all created mailer files.

= Application Extensions and Helpers (padrino-helpers)

=== Overview

This component provides a great deal of view helpers related to html markup generation.
There are helpers for generating tags, forms, links, images, and more. Most of the basic
methods should be very familiar to anyone who has used rails view helpers.


=== Output Helpers

Output helpers are a collection of important methods for managing, capturing and displaying output
in various ways and is used frequently to support higher-level helper functions. There are
three output helpers worth mentioning: <tt>content_for</tt>, <tt>capture_html</tt>, and <tt>concat_content</tt> 

The content_for functionality supports capturing content and then rendering this into a different place
such as within a layout. One such popular example is including assets onto the layout from a template:

  # app/views/site/index.erb
  ...
  <% content_for :assets do %>
    <%= stylesheet_link_tag 'index', 'custom' %>
  <% end %>
  ...
  
Added to a template, this will capture the includes from the block and allow them to be yielded into the layout:

  # app/views/layout.erb
  ...
  <head>
    <title>Example</title>
    <%= stylesheet_link_tag 'style' %>
    <%= yield_content :assets %>
  </head>
  ...
  
This will automatically insert the contents of the block (in this case a stylesheet include) into the 
location the content is yielded within the layout.

The capture_html and the concat_content methods allow content to be manipulated and stored for use in building
additional helpers accepting blocks or displaying information in a template. One example is the use of
these in constructing a simplified 'form_tag' helper which accepts a block.

  # form_tag '/register' do ... end
  def form_tag(url, options={}, &block)
    # ... truncated ...
    inner_form_html = capture_html(&block)
    concat_content '<form>' + inner_form_html + '</form>'
  end
  
This will capture the template body passed into the form_tag block and then append the content
to the template through the use of <tt>concat_content</tt>. Note have been built to work for both haml and erb 
templates using the same syntax.

The list of defined helpers in the 'output helpers' category:

* <tt>content_for(key, &block)</tt>
  * Capture a block of content to be rendered at a later time.
  * <tt>content_for(:head) { ...content... }</tt>
  * Also supports arguments passed to the content block
  * <tt>content_for(:head) { |param1, param2| ...content... }</tt>
* <tt>yield_content(key, *args)</tt>
  * Render the captured content blocks for a given key.
  * <tt>yield_content :head</tt>
  * Also supports arguments yielded to the content block
  * <tt>yield_content :head, param1, param2</tt>
* <tt>capture_html(*args, &block)</tt>
  * Captures the html from a block of template code for erb or haml
  * <tt>capture_html(&block)</tt> => "...html..."
* <tt>concat_content(text="")</tt>
  * Outputs the given text to the templates buffer directly in erb or haml
  * <tt>concat_content("This will be output to the template buffer in erb or haml")</tt>

=== Tag Helpers

Tag helpers are the basic building blocks used to construct html 'tags' within a view template. There
are three major functions for this category: <tt>tag</tt>, <tt>content_tag</tt> and <tt>input_tag</tt>.

The tag and content_tag are for building arbitrary html tags with a name and specified options. If
the tag contains 'content' within then <tt>content_tag</tt> is used. For example:

  tag(:br, :style => ‘clear:both’) => <br style="clear:both" />
  content_tag(:p, "demo", :class => ‘light’) => <p class="light">demo</p>
  
The input_tag is used to build tags that are related to accepting input from the user:

  input_tag :text, :class => "demo" => <input type='text' class='demo' />
  input_tag :password, :value => "secret", :class => "demo"
  
Note that all of these accept html options and result in returning a string containing html tags.

The list of defined helpers in the 'tag helpers' category:

* <tt>tag(name, options={})</tt>
  * Creates an html tag with the given name and options
  * <tt>tag(:br, :style => 'clear:both')</tt> => <br style="clear:both" />
  * <tt>tag(:p, :content => "demo", :class => 'large')</tt> => <p class="large">demo</p>
* <tt>content_tag(name, content, options={})</tt>
  * Creates an html tag with given name, content and options
  * <tt>content_tag(:p, "demo", :class => 'light')</tt> => <p class="light">demo</p>
  * <tt>content_tag(:p, :class => 'dark') { ...content... }</tt> => <p class="dark">...content...</p>
* <tt>input_tag(type, options = {})</tt>
  * Creates an html input field with given type and options
  * <tt>input_tag :text,     :class => "demo"</tt>
  * <tt>input_tag :password, :value => "secret", :class => "demo"</tt>

=== Asset Helpers

Asset helpers are intended to help insert useful html onto a view template such as 'flash' notices,
hyperlinks, mail_to links, images, stylesheets and javascript. An example of their uses would be on a 
simple view template:

  # app/views/example.haml
  ...
  %head
    = stylesheet_link_tag 'layout'
    = javascript_include_tag 'application'
  %body
    ...
    = flash_tag :notice
    %p= link_to 'Blog', '/blog', :class => 'example'
    %p Mail me at #{mail_to 'fake@faker.com', "Fake Email Link", :cc => "test@demo.com"}
    %p= image_tag 'padrino.png', :width => '35', :class => 'logo'

The list of defined helpers in the 'asset helpers' category:

* <tt>flash_tag(kind, options={})</tt>
  * Creates a div to display the flash of given type if it exists
  * <tt>flash_tag(:notice, :class => 'flash', :id => 'flash-notice')</tt>
* <tt>link_to(*args, &block)</tt>
  * Creates a link element with given name, url and options
  * <tt>link_to 'click me', '/dashboard', :class => 'linky'</tt>
  * <tt>link_to('/dashboard', :class => 'blocky') { ...content... }</tt>
* <tt>mail_to(email, caption=nil, mail_options={})</tt>
  * Creates a mailto link tag to the specified email_address
  * <tt>mail_to "me@demo.com"</tt>
  * <tt>mail_to "me@demo.com", "My Email", :subject => "Feedback", :cc => 'test@demo.com'</tt>
* <tt>image_tag(url, options={})</tt>
  * Creates an image element with given url and options
  * <tt>image_tag('icons/avatar.png')</tt>
* <tt>stylesheet_link_tag(*sources)</tt>
  * Returns a stylesheet link tag for the sources specified as arguments
  * <tt>stylesheet_link_tag 'style', 'application', 'layout'</tt>
* <tt>javascript_include_tag(*sources)</tt>
  * Returns an html script tag for each of the sources provided.
  * <tt>javascript_include_tag 'application', 'special'</tt>
  
=== Form Helpers

Form helpers are the 'standard' form tag helpers you would come to expect when building forms. A simple
example of constructing a non-object form would be:

  - form_tag '/destroy', :class => 'destroy-form', :method => 'delete' do
    = flash_tag(:notice)
    - field_set_tag do
      %p
        = label_tag :username, :class => 'first'
        = text_field_tag :username, :value => params[:username]
      %p
        = label_tag :password, :class => 'first'
        = password_field_tag :password, :value => params[:password]
      %p
        = label_tag :strategy
        = select_tag :strategy, :options => ['delete', 'destroy'], :selected => 'delete'
      %p
        = check_box_tag :confirm_delete
    - field_set_tag(:class => 'buttons') do
      = submit_tag "Remove"

The list of defined helpers in the 'form helpers' category:

* <tt>form_tag(url, options={}, &block)</tt>
  * Constructs a form without object based on options
  * Supports form methods 'put' and 'delete' through hidden field
  * <tt>form_tag('/register', :class => 'example') { ... }</tt>
* <tt>field_set_tag(*args, &block)</tt>
  * Constructs a field_set to group fields with given options
  * <tt>field_set_tag(:class => 'office-set') { }</tt>
  * <tt>field_set_tag("Office", :class => 'office-set') { }</tt>
* <tt>error_messages_for(:record, options={})</tt>
  * Constructs list html for the errors for a given object
  * <tt>error_messages_for @user</tt>
* <tt>label_tag(name, options={}, &block)</tt>
  * Constructs a label tag from the given options
  * <tt>label_tag :username, :class => 'long-label'</tt>
  * <tt>label_tag(:username, :class => 'blocked-label') { ... }</tt>
* <tt>hidden_field_tag(name, options={})</tt>
  * Constructs a hidden field input from the given options
  * <tt>hidden_field_tag :session_key, :value => 'secret'</tt>
* <tt>text_field_tag(name, options={})</tt>
  * Constructs a text field input from the given options
  * <tt>text_field_tag :username, :class => 'long'</tt>
* <tt>text_area_tag(name, options={})</tt>
  * Constructs a text area input from the given options
  * <tt>text_area_tag :username, :class => 'long'</tt>
* <tt>password_field_tag(name, options={})</tt>
  * Constructs a password field input from the given options
  * <tt>password_field_tag :password, :class => 'long'</tt>
* <tt>check_box_tag(name, options={})</tt>
  * Constructs a checkbox input from the given options
  * <tt>check_box_tag :remember_me, :checked => true</tt>
* <tt>radio_button_tag(name, options={})</tt>
  * Constructs a radio button input from the given options
  * <tt>radio_button_tag :gender, :value => 'male'</tt>
* <tt>select_tag(name, settings={})</tt>
  * Constructs a select tag with options from the given settings
  * <tt>select_tag(:favorite_color, :options => ['1', '2', '3'], :selected => '1')</tt>
  * <tt>select_tag(:more_color, :options => [['label', '1'], ['label2', '2']])</tt>
  * <tt>select_tag(:multiple_color, :options => [...], :multiple => true)</tt>
* <tt>file_field_tag(name, options={})</tt>
  * Constructs a file field input from the given options
  * <tt>file_field_tag :photo, :class => 'long'</tt>
* <tt>submit_tag(caption, options={})</tt>
  * Constructs a submit button from the given options
  * <tt>submit_tag "Create", :class => 'success'</tt>
* <tt>button_tag(caption, options={})</tt>
  * Constructs an input (type => 'button') from the given options
  * <tt>button_tag "Cancel", :class => 'clear'</tt>
* <tt>image_submit_tag(source, options={})</tt>
  * Constructs an image submit button from the given options
  * <tt>image_submit_tag "submit.png", :class => 'success'</tt>
    
=== FormBuilders

Form builders are full-featured objects allowing the construction of complex object-based forms
using a simple, intuitive syntax.

A form_for using these basic fields might look like:

  - form_for @user, '/register', :id => 'register' do |f|
    = f.error_messages
    %p
      = f.label :username, :caption => "Nickname"
      = f.text_field :username
    %p
      = f.label :email
      = f.text_field :email
    %p
      = f.label :password
      = f.password_field :password
    %p
      = f.label :is_admin, :caption => "Admin User?"
      = f.check_box :is_admin
    %p
      = f.label :color, :caption => "Favorite Color?"
      = f.select :color, :options => ['red', 'black']
    %p
      - fields_for @user.location do |location|
        = location.text_field :street
        = location.text_field :city
    %p
      = f.submit "Create", :class => 'button'

The list of defined helpers in the 'form builders' category:

* <tt>form_for(object, url, settings={}, &block)</tt>
  * Constructs a form using given or default form_builder
  * Supports form methods 'put' and 'delete' through hidden field
  * Defaults to StandardFormBuilder but you can easily create your own!
  * <tt>form_for(@user, '/register', :id => 'register') { |f| ...field-elements... }</tt>
  * <tt>form_for(:user, '/register', :id => 'register') { |f| ...field-elements... }</tt>
* <tt>fields_for(object, settings={}, &block)</tt>
  * Constructs fields for a given object for use in an existing form
  * Defaults to StandardFormBuilder but you can easily create your own!
  * <tt>fields_for @user.assignment do |assignment| ... end</tt>
  * <tt>fields_for :assignment do |assigment| ... end</tt>

The following are fields provided by AbstractFormBuilder that can be used within a form_for or fields_for:

* <tt>error_messages(options={})</tt>
  * Displays list html for the errors on form object
  * <tt>f.errors_messages</tt>
* <tt>label(field, options={})</tt>
  * <tt>f.label :name, :class => 'long'</tt>
* <tt>text_field(field, options={})</tt>
  * <tt>f.text_field :username, :class => 'long'</tt>
* <tt>check_box(field, options={})</tt>
  * Uses hidden field to provide a 'unchecked' value for field
  * <tt>f.check_box :remember_me, :uncheck_value => 'false'</tt>
* <tt>radio_button(field, options={})</tt>
  * <tt>f.radio_button :gender, :value => 'male'</tt>
* <tt>hidden_field(field, options={})</tt>
  * <tt>f.hidden_field :session_id, :class => 'hidden'</tt>
* <tt>text_area(field, options={})</tt>
  * <tt>f.text_area :summary, :class => 'long'</tt>
* <tt>password_field(field, options={})</tt>
  * <tt>f.password_field :secret, :class => 'long'</tt>
* <tt>file_field(field, options={})</tt>
  * <tt>f.file_field :photo, :class => 'long'</tt>
* <tt>select(field, options={})</tt>
  * <tt>f.select(:state, :options => ['California', 'Texas', 'Wyoming'])</tt>
  * <tt>f.select(:state, :collection => @states, :fields => [:name, :id])</tt>
  * <tt>f.select(:state, :options => [...], :include_blank => true)</tt>
* <tt>submit(caption, options={})</tt>
  * <tt>f.submit "Update", :class => 'long'</tt>
* <tt>image_submit(source, options={})</tt>
  * <tt>f.image_submit "submit.png", :class => 'long'</tt>
  
There is also an additional StandardFormBuilder which builds on the abstract fields that can be used within a form_for.

A form_for using these standard fields might be:

  - form_for @user, '/register', :id => 'register' do |f|
    = f.error_messages
    = f.text_field_block :name, :caption => "Full name"
    = f.text_field_block :email
    = f.check_box_block  :remember_me
    = f.select_block     :fav_color, :options => ['red', 'blue']
    = f.password_field_block :password
    = f.submit_block "Create", :class => 'button'

and would generate this html (with each input contained in a paragraph and containing a label):

  <form id="register" action="/register" method="post">
    <p><label for="user_name">Full name: </label><input type="text" id="user_name" name="user[name]"></p>
    ...omitted...
    <p><input type="submit" value="Create" class="button"></p>
  </form>

The following are fields provided by StandardFormBuilder that can be used within a form_for or fields_for:

* <tt>text_field_block(field, options={}, label_options={})</tt>
  * <tt>text_field_block(:nickname, :class => 'big', :caption => "Username")</tt>
* <tt>text_area_block(field, options={}, label_options={})</tt>
  * <tt>text_area_block(:about, :class => 'big')</tt>
* <tt>password_field_block(field, options={}, label_options={})</tt>
  * <tt>password_field_block(:code, :class => 'big')</tt>
* <tt>file_field_block(field, options={}, label_options={})</tt>
  * <tt>file_field_block(:photo, :class => 'big')</tt>
* <tt>check_box_block(field, options={}, label_options={})</tt>
  * <tt>check_box_block(:remember_me, :class => 'big')</tt>
* <tt>select_block(field, options={}, label_options={})</tt>
  * <tt>select_block(:country, :option => ['USA', 'Canada'])</tt>
* <tt>submit_block(caption, options={})</tt>
  * <tt>submit_block(:username, :class => 'big')</tt>
* <tt>image_submit_block(source, options={})</tt>
  * <tt>image_submit_block('submit.png', :class => 'big')</tt>

You can also easily build your own FormBuilder which allows for customized fields and behavior:

  class MyCustomFormBuilder < AbstractFormBuilder
    # Here we have access to a number of useful variables
    #
    #   * template  (use this to invoke any helpers)(ex. template.hidden_field_tag(...))
    #   * object    (the record for this form) (ex. object.valid?)
    #   * object_name (object's underscored type) (ex. object_name => 'admin_user')
    #
    # We also have access to self.field_types => [:text_field, :text_area, ...]
    # In addition, we have access to all the existing field tag helpers (text_field, hidden_field, file_field, ...)
  end

Once a custom builder is defined, any call to form_for can use the new builder:

  - form_for @user, '/register', :builder => 'MyCustomFormBuilder', :id => 'register' do |f|
    ...fields here...

The form builder can even be made into the default builder when form_for is invoked:

  # anywhere in the Padrino or Sinatra application
  set :default_builder, 'MyCustomFormBuilder'

And there you have it, a fairly complete form builder solution for Padrino (and Sinatra). 
I hope to create or merge in an even better 'default' form_builder in the near future.

=== Format Helpers

Format helpers are several useful utilities for manipulating the format of text to achieve a goal.
The four format helpers are <tt>escape_html</tt>, <tt>relative_time_ago</tt>, <tt>time_in_words</tt>,
and <tt>js_escape_html</tt>.

The escape_html and js_escape_html function are for taking an html string and escaping certain characters.
<tt>escape_html</tt> will escape ampersands, brackets and quotes to their HTML/XML entities. This is useful
to sanitize user content before displaying this on a template. <tt>js_escape_html</tt> is used for 
passing javascript information from a js template to a javascript function.

  escape_html('<hello>&<goodbye>') # => &lt;hello&gt;&amp;&lt;goodbye&gt;

There is also an alias for escape_html called <tt>h</tt> for even easier usage within templates.

Format helpers also includes a number of useful text manipulation functions such as <tt>simple_format</tt>,
<tt>pluralize</tt>, <tt>word_wrap</tt>, and <tt>truncate</tt>. 

  simple_format("hello\nworld") # => "<p>hello<br/>world</p>"
  pluralize(2, 'person') => '2 people'
  word_wrap('Once upon a time', :line_width => 8) => "Once upon\na time"
  truncate("Once upon a time in a world far far away", :length => 8) => "Once upon..."

These helpers can be invoked from any route or view within your application.

The list of defined helpers in the 'format helpers' category:

* <tt>simple_format(text, html_options)</tt>
  * Returns text transformed into HTML using simple formatting rules.
  * <tt>simple_format("hello\nworld")</tt> => "<p>hello<br/>world</p>"
* <tt>pluralize(count, singular, plural = nil)</tt>
  * Attempts to pluralize the singular word unless count is 1.
  * <tt>pluralize(2, 'person')</tt> => '2 people'
* <tt>word_wrap(text, *args)</tt>
  * Wraps the text into lines no longer than line_width width.
  * <tt>word_wrap('Once upon a time', :line_width => 8)</tt> => "Once upon\na time"
* <tt>truncate(text, *args)</tt>
  * Truncates a given text after a given :length if text is longer than :length (defaults to 30).
  * <tt>truncate("Once upon a time in a world far far away", :length => 8)</tt> => "Once upon..."
* <tt>escape_html</tt> (alias <tt>h</tt> and <tt>h!</tt>)
  * (from RackUtils) Escape ampersands, brackets and quotes to their HTML/XML entities.
* <tt>relative_time_ago(date)</tt>
  * Returns relative time in words referencing the given date
  * <tt>relative_time_ago(2.days.ago)</tt> => "2 days"
  * <tt>relative_time_ago(5.minutes.ago)</tt> => "5 minutes"
  * <tt>relative_time_ago(2800.days.ago)</tt> => "over 7 years"
* <tt>time_in_words(date)</tt>
  * Returns relative time in the past or future using appropriate date format
  * <tt>time_in_words(2.days.ago)</tt> => "2 days ago"
  * <tt>time_in_words(100.days.ago)</tt> => "Tuesday, July 21"
  * <tt>time_in_words(1.day.from_now)</tt> => "tomorrow"
* <tt>js_escape_html(html_content)</tt>
  * Escapes html to allow passing information to javascript. Used for passing data inside an ajax .js.erb template
  * <tt>js_escape_html("<h1>Hey</h1>")</tt>

See the wiki article for additional information: <...WIKI...>

=== Render Helpers

This component provides a number of rendering helpers making the process of displaying templates a bit easier. 
This plugin also has support for useful additions such as partials (with support for :collection) for the templating system.

Using render plugin helpers is extremely simple. If you want to render an erb template in your view path:

  erb_template 'path/to/my/template'
  
or using haml templates works just as well:

  haml_template 'path/to/haml/template'
  
There is also a method which renders the first view matching the path and removes the need to define an engine:

  render_template 'path/to/any/template'
  
It is worth noting these are mostly for convenience. With nested view file paths in Sinatra, this becomes tiresome:

  haml :"the/path/to/file"
  erb "/path/to/file".to_sym
  
Finally, we have the all-important partials support for rendering mini-templates onto a page:

  partial 'photo/_item', :object => @photo, :locals => { :foo => 'bar' }
  partial 'photo/_item', :collection => @photos
  
This works as you would expect and also supports the collection counter inside the partial <tt>item_counter</tt>

  # /views/photo/_item.haml
  # Access to collection counter with <partial_name>_counter i.e item_counter
  # Access the object with the partial_name i.e item
  
The list of defined helpers in the 'render helpers' category:

* <tt>erb_template(template_path, options={})</tt>
  * Renders a erb template based on the given path
  * <tt>erb_template 'users/new'</tt>
* <tt>haml_template(template_path, options={})</tt>
  * Renders a haml template based on the given path
  * <tt>haml_template 'users/new'</tt>
* <tt>render_template(template_path, options={})</tt>
  * Renders the first detected template based on the given path
  * <tt>render_template 'users/new'</tt>
  * <tt>render_template 'users/index', :template_engine => 'haml'</tt>
* <tt>partial(template, *args)</tt>
  * Renders the html related to the partial template for object or collection
  * <tt>partial 'photo/_item', :object => @photo, :locals => { :foo => 'bar' }</tt>
  * <tt>partial 'photo/_item', :collection => @photos</tt>

See the wiki article for additional information: <...WIKI...>

= Admin Dashboard and Authentication (padrino-admin)

=== Overview

Padrino has a beautiful Ajax Admin, with these fatures:

Orm Agnostic:: Adapters for datamapper, activerecord, mongomapper, couchdb (now only: datamapper and activerecord)
Authentication:: Support for Account authentication, Account Permission managment
Scaffold:: You can simply create a new "admin interface" simply providing a Model
Ajax Uploads:: You can upload file, manage them and attach them to any model in a quick and simple way (coming soon)

=== Admin Usage

Create a project:

  $ padrino-gen app fun-test
  $ cd fun-test

For create the admin application:

  fun-test$ padrino-gen admin

Now follow admin instructions so:

* edit your config/database.rb
* run padrino rake dm:auto:migrate
* run padrino rake seed

Your admin now is "complete", you can start your server with <tt>padrino start</tt> and point your browser to /admin!

For create a new "scaffold" you need to provide only a Model for them like:

  fun-test$ padrino-gen model post --skip-migration // edit your post.rb model and add some fields
  fun-test$ padrino-gen rake dm:auto:migrate
  fun-test$ padrino-gen admin_page Post
  fun-test$ padrino start // and go to yourserver.local/admin
  
That's all!!

=== Admin Authentication

Padrino Admin use a model Account for manage role, membership and permissions take the following example:

  access_control.roles_for :any do |role|
    role.allow "/sessions"
    # role.deny "/deny/this/always"
  end

  access_control.roles_for :admin do |role, account|
    role.allow "/"

    role.project_module :accounts do |project|
      project.menu :list, "/admin/accounts.js"
      project.menu :new,  "/admin/accounts/new"
    end
  end

  access_control.roles_for :editor do |role, account|
    role.project_module :posts do |project|
      project.menu :list, "/admin/posts.js"
      project.menu :new,  "/admin/posts/new"
    end

    role.project_module :comments do |project|
      project.menu :list, "/admin/comments.js"
      project.menu :new,  "/admin/comments/new"
    end
  end

In this example we <tt>grant</tt> "/session" (and each subpaths like /sessions/new) for all users logged and unlogged.

Account with role <tt>admin</tt> can manage <tt>only</tt> accounts because have access to "/admin/accounts/**" paths
Account with role <tt>editor</tt> can manage <tt>only</tt> post/comments because have access to "/admin/posts/**", "/admin/posts/**" paths

Another good fature of Padrino admin is that when you define a <tt>Project Module</tt> role you also build the Menu Tree of the Admin. 
Trust us that in future you appreciate so much this feature.

=== Admin Uploads

Padrino admin has a builtin upload managment that leave you to be free as possible.

  fun-test$ padrino-gen admin_uploader
  fun-test$ rake dm:auto:upgrade # or ar:migrate

Finish! Now you can browse into your admin and you can see a new menu called +upload+ where you can see all your uploads,
upload other file, delete ...

All upload definitions are defined in lib/uploader.rb, here you can preproces your attachments (like resize) or manage versions.

See http://github.com/jnicklas/carrierwave

==== Attach Many Uploads to a Model

If you want attach in a model ex: Account many uploads you can do that in a simple way add a habtm relation!

  # app/models/account.rb
  has n, :uploads

or for ActiveRecord

  # app/models/account.rb
  has_and_belongs_to_many :uploads

Now edit the form and add these lines:

  # admin/views/accounts/_form.haml
  %tr
    %td=f.label :uploads
    %td=open_window_grid :account, :upload_ids, :with => :uploads, :get => :id, :show => :file, :multiple => true, :item => :panel

*open_window_grid* is a padrino-admin method that open an extjs window contains your +grids+ so in this case:

open window grid for :+account+ model in method :+upload_ids+ with the help of controller :+uploads+ and 
get as a value the :+id+ and display :+file+.

:+multiple+ indicate that we need more than one :+id+.
:+item+ tell to the grid who is the container, we need to explicit this because we have two container in our upload.js

See view helpers[http://github.com/padrino/padrino-framework/blob/master/padrino-admin/lib/padrino-admin/helpers/view.rb#L145] for more docs.

That's all! Now run mingrations and browse accounts for see our uploader.

==== Attach One Upload to a Model

The process is the same as above you need only define in your model:

  # app/models/account.rb
  belongs_to :upload

and add this to your account form:

  # admin/views/accounts/_form.haml
  %tr
    %td=f.label :upload
    %td=open_window_grid :account, :upload_id, :with => :uploads, :get => :id, :show => :file, :item => :panel

Remember to run migrations before start your server.

= Simple Mailer Support (padrino-mailer)

=== Overview

This component uses an enhanced version of the excellent <tt>pony</tt> library (vendored) for a powerful but simple
mailer system within Padrino (and Sinatra). There is full support for using an html content type as well as for file attachments.
The MailerPlugin has many similarities to ActionMailer but is much lighterweight and (arguably) easier to use.

=== Usage

Let's take a look at using the MailerPlugin in an application. By default, MailerPlugin uses the built-in sendmail
functionality on the server. However, smtp is also supported using the following configuration:

    Padrino::Mailer::Base.smtp_settings = {
      :host   => 'smtp.gmail.com',
      :port   => '587',
      :tls    => true,
      :user   => 'user',
      :pass   => 'pass',
      :auth   => :plain
   }

Once those have been defined, the default will become smtp delivery unless overwritten in an individual mail definition.
Next, we should define a custom mailer extended from <tt>Padrino::Mailer::Base</tt>.

  # app/mailers/sample_mailer.rb
  class SampleMailer < Padrino::Mailer::Base
    def registration_email(name, user_email_address)
      from 'admin@site.com'
      to user_email_address
      subject 'Welcome to the site!'
      body    :name => name
      type    'html'                # optional, defaults to plain/text
      charset 'windows-1252'        # optional, defaults to utf-8
      via     :sendmail             # optional, to smtp if defined otherwise sendmail
    end
  end

This defines a mail called '<tt>registration_mail</tt>' with the specified attributes for delivery. The <tt>body</tt> method
is passing the <tt>name</tt> attribute to the body message template which should be defined in
<tt>[views_path]/sample_mailer/registration_email.erb</tt> as shown below:

  # ./views/sample_mailer/registration_email.erb
  This is the body of the email and can access the <%= name %> that was passed in from the mailer definition
  That's all there is to defining the body of the email which can be plain text or html

Once the mailer definition has been completed and the template has been defined, the email can be sent using:

  SampleMailer.deliver(:registration_email, "Bob", "bob@bobby.com")

or if you like the method_missing approach:

  SampleMailer.deliver_registration_email "Bob", 'bob@bobby.com'

And that will then deliver the email according the the configured options. This is really all you need to send emails.
A few variations are shown below for completeness.

If we want to attach files to our email:

  # app/mailers/sample_mailer.rb
  class SampleMailer < Padrino::Mailer::Base
    def attachment_email(name, user_email_address)
      from 'admin@site.com'
      to user_email_address
      # ...
      attachments { "foo.zip" => File.read("path/to/foo.zip"), "file.txt" => "this is a text file!" }
    end
  end

or perhaps we want to have a short body without the need for a template file:

  # app/mailers/sample_mailer.rb
  class SampleMailer < Padrino::Mailer::Base
    def short_email(name, user_email_address)
      from 'admin@site.com'
      to user_email_address
      subject 'Welcome to the site!'
      body    "This is a short body defined right in the mailer itself"
    end
  end

See the wiki article for additional information: <...WIKI...>

= Painless Page and Fragment Caching (padrino-cache)

Not implemented yet.

== Copyright

Copyright (c) 2010 Padrino. See LICENSE for details.

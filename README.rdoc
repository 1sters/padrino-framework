= Padrino (padrino-core)

Padrino is the godfather of Sinatra.

== Preface

Padrino is a ruby framework built upon the excellent {Sinatra Microframework}[http://www.sinatrarb.com]. 
Sinatra is a DSL for creating simple web applications in Ruby with speed and minimal effort. 
This framework tries hard to make it as fun and easy as possible to code much more advanced web applications by 
building upon the Sinatra philosophies and foundation.

== Introduction

Many people love Sinatra's simplicity and lightweight but often quickly come to miss a great deal
of functionality provided by other web frameworks such as Rails when building non-trivial applications.

Our goal with this framework is to match the essence of Sinatra and at the same time create a standard library
of tools, helpers and components that will make Sinatra suitable for more complex applications.

Here is a brief overview of functionality provided by the Padrino framework:

Generators:: for creating new padrino applications i.e.: <tt>padrino-gen app</tt> or <tt>padrino start</tt> on command line
MultiApp:: unlike other ruby frameworks Padrino is principally designed for mounting multiple apps at the same time.
Routing:: Full url named route, named params, respond_to suppor
Tag Helpers:: helpers such as: <tt>tag</tt>, <tt>content_tag</tt>, <tt>input_tag</tt>, ...
Asset Helpers:: helpers such as: <tt>link_to</tt>, <tt>image_tag</tt>, <tt>javascript_include_tag</tt>, ...
Form Helpers:: with builder support such as: <tt>form_tag</tt>, <tt>form_for</tt>, <tt>field_set_tag</tt>, <tt>text_field</tt>, ...
Text Helpers:: useful formatting extensions like: <tt>relative_time_ago</tt>, <tt>js_escape_html</tt>, <tt>sanitize_html</tt>
Mailer:: fast, tiny, delivery support for send templating emails (like ActionMailer do)
Admin:: an ajax admin that displays your records in sortable grids, tree, windows ... as a desktop app can do.
Logging:: Padrino provide a logger that can interact with your orm or any other library
Reloading:: With padrino is not necessary like other framework start and restart your server for see changes.
I18n:: Padrino has a full support of I18n and can autoset locale.

Keep in mind, the user will be able to pull in these components 
{seperately into existing Sinatra applications}[http://wiki.github.com/padrino/padrino-framework/standalone-usage-in-sinatra]
or use them altogether for a comprehensive upgrade to Sinatra (a full-stack Padrino application).

== Installation

To install the padrino framework, simply grab the latest version from gemcutter:

  $ sudo gem install padrino
  
This will install the necessary padrino gems to get you started.
Now you are ready to use this gem to enhance your sinatra projects or to create new Padrino applications.

For a more detailed look at Padrino installation, 
check out the {Installation Guide}[http://wiki.github.com/padrino/padrino-framework/installation].

== Usage

Padrino is a framework which builds on the existing functionality and Sinatra and provides a variety of 
additional tools and helpers to build upon that foundation. This README and Padrino documentation in general will focus
on the enhancements to the core Sinatra functionality. To use Padrino, one should be familiar with the basic 
usage of Sinatra itself. Resources for Sinatra are listed below:

* {Sinatra Introduction}[http://www.sinatrarb.com/intro.html]
* {Sinatra Book}[http://www.sinatrarb.com/book.html]
* {Sinatra Github Repo}[http://github.com/sinatra/sinatra]

Below is a guide to how this gem enhances the Sinatra framework as part of a 'full-stack' padrino application.
For information on how to use a specific gem in isolation within an existing Sinatra project, checkout the guide for
{Using Padrino in Sinatra}[http://wiki.github.com/padrino/padrino-framework/standalone-usage-in-sinatra].

== Enhanced Base Application (padrino-core)

Sinatra has support for classes which can be extended to create an application: <tt>Sinatra::Base</tt> and <tt>Sinatra::Application</tt>
These classes can be extended in order to create a Sinatra web application. These classes provide support for all the basic
functionality afforded by Sinatra.

Padrino has support for an enhanced base application class <tt>Padrino::Application</tt>. <tt>Padrino::Application</tt>
expands the capabilities of Sinatra::Application and automatically provides the resulting application access to all of
the padrino framework's functionalities. 

=== Simple Application Definition

Let us first take a look at the simplest possible Padrino application:

  # app.rb
  PADRINO_ROOT = File.dirname(__FILE__) unless defined? PADRINO_ROOT
  require 'padrino'
  Padrino.load!

  class SimpleApp < Padrino::Application
    get '/' do
      'Hello world'
    end
    
    # and for read better we can divide with controllers
    controller '/admin' do
      get '/foo' do
        'Url is /admin/foo'
      end
    end
  end

=== Enhanced Route Definitions and Controllers

For a complete overview of the Padrino routing and controller system, 
check out the {Routing and Controller guide}[http://wiki.github.com/padrino/padrino-framework/controllers].

Suppose we wanted to add additional routes to our Padrino application, and we want to organize the routes
within a more structured layout. Simply add a <tt>controllers</tt> or <tt>app/controllers</tt> folder and create a file as such:

  # Simple Example
  SimpleApp.controllers do
    get "/test" do
      "Text to return"
    end
  end
  
You can also do more complex route alias definitions:

  # app/controllers/example.rb
  SimpleApp.controllers :posts do
    get :index do
      ...
    end

    get :show, :with => :id do
      # url generated is '/posts/show/:id'
      # access params[:id]
    end
  end

as well as mapping the route aliases to an explicit url:
  
  # app/controllers/example.rb
  SimpleApp.controllers do
    get :index, :map => '/index' do
      ...
    end

    get :account, :map => '/the/accounts/:name/and/:id' do
      # access params[:name] and params[:index]
    end
  end
  
and even configure the respond_to for each route:
  
  # app/controllers/example.rb
  SimpleApp.controllers :admin do
    get :show, :with => :id, :respond_to => :js do
      "Url is /admin/show/#{params[:id]}.#{params[:format]}"
    end

    get :other, with => [:id, :name], respond_to => [:html, :json] do
      case content_type
        when :js    then ... end
        when :json  then ... end
      end
    end
  end
  
For a complete overview of the routing and controller system, check out the 
{Routing and Controller guide}[http://wiki.github.com/padrino/padrino-framework/controllers].
  
=== Rendering

Unlike Sinatra, Padrino supports automatic template lookups such as:

  # searches for 'account/index.{erb,haml,...}
  render 'account/index'
  
This render does not require any template engine to be specified and will choose the first one that is discovered. 
The existing render function works as well if an engine type should be specified:

# example.haml
render :haml, 'account/index'

For a complete overview of the Padrino rendering system, check out the 
{Routing and Controller guide}[http://wiki.github.com/padrino/padrino-framework/controllers].

=== Layout

With Padrino you can (like rails do) use for your custom layout, disable it

  class SimpleApp < Padrino::Application
    
    # Disable layouts
    disable layout
    
    # Use the layout located in views/layouts/custom.haml
    layout :custom
    
For a complete overview of the layout functionality, 
check out the {Routing and Controller guide}[http://wiki.github.com/padrino/padrino-framework/controllers].

=== Mounting Applications

Padrino applications are all automatically mountable into other Padrino projects. This means that a given Padrino
project directory can easily mount multiple applications. This allows for better organization of complex applications,
re-usable applications that can be applied (i.e admin, auth, blog) and even more flexibility. 

You can think of mountable applications as a 'full-featured' merb slice or rails engine. Instead of a separate construct, 
any application can simply be packaged and mounted into another project.

Padrino stores application mounting information by default within <tt>config/apps.rb</tt>. This file is intended
to keep all information regarding what applications are mounted to which uri's. 

For a complete look at mounting applications within a Padrino project, 
check out the guide on {Mounting Applications}[http://wiki.github.com/padrino/padrino-framework/mounting-applications].

=== Auto Load Paths

Padrino also intelligently supports requiring useful files within your application automatically and provides
functionality for easily splitting up your application into separate files. Padrino automatically requires <tt>config/database.rb</tt>
as a convention for establishing database connection. Also, any files within the <tt>lib</tt> folder will be required 
automatically by Padrino.

For a complete overview of auto-loaded paths within Padrino, 
check out the {Padrino Development Guide}[http://wiki.github.com/padrino/padrino-framework/development-and-terminal-commands].

=== Application Logging

Padrino also supports robust logging capabilities. By default, logging information will
go to the STDOUT in development (for use in a console) and in an environment-specific log file <tt>log/development.log</tt>
in test and production environments.
  
To use the logger within a Padrino application, simply refer to the <tt>logger</tt> method accessible
within your app and any controller or views:

  # controllers/example.rb
  SimpleApp.controllers do
    get("/test") { logger.info "This is a test" }
  end
  
For a complete overview of Padrino logger functionality, check out the 
{Padrino Development Guide}[http://wiki.github.com/padrino/padrino-framework/development-and-terminal-commands].

=== Development Reloader

Padrino applications also have the enabled ability to automatically reload all changing application files without
the need to restart the server. Through the use of a customized Rack middleware, all files on the 'load path'
are monitored and reloaded whenever changes are applied. 

This makes rapid development much easier and provides a better alternative to 'shotgun' or 'rerun' 
which requires the application server to be restarted which makes requests take much longer to complete.

For a complete overview of code reloading in development, 
check out the {Padrino Development Guide}[http://wiki.github.com/padrino/padrino-framework/development-and-terminal-commands].

=== Terminal Commands

Padrino also comes equipped with multiple useful terminal commands which can be activated to perform
common tasks such as starting / stopping the application, executing the unit tests or activating an irb session.

The following commands are available:

  # starts the app server (non-daemonized)
  $ padrino start
  # starts the app server (daemonized) with given port, environment and adapter
  $ padrino start -d -p 3000 -e development -a thin 
  
  # Stops a daemonized app server
  $ padrino stop
  
  # Bootup the Padrino console (irb)
  $ padrino console
  
  # Run/List tasks
  $ padrino rake

You can also create custom rake tasks as well. Using these commands can simplify common tasks 
making development that much smoother.

For a complete overview of Padrino terminal commands, check out the 
{Padrino Commands Guide}[http://wiki.github.com/padrino/padrino-framework/development-and-terminal-commands].

= Agnostic Application Generators (padrino-gen)

=== Overview

Padrino comes preloaded with flexible code generators powered in part by the excellent Thor gem
(incidentally also used in the Rails 3 generators). These generators are intended to allow for easy code generation
both in creating new applications and building on existing ones. The generators have been built to be as library agnostic
as possible, supporting a myriad of test frameworks, js libraries, mocking libraries, etc.

See the guide for {Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators] for a
more in-depth look at the system.

=== Application Generator

Padrino provides generator support for quickly creating new Padrino applications. This provides many benefits
such as constructing the recommended Padrino application structure, auto-generating a Gemfile listing
all starting dependencies and guidelines provided within the generated files to help orient a new user
to using Padrino.

One important feature of the generators is that they were built from the ground up to support a wide variety
of tools, libraries and gems for use within your padrino application. 

The simplest possible command to generate a base application would be:

  $ padrino-gen project demo_project
  
This would construct a Padrino application DemoApp (which extends from Padrino::Application) 
inside the folder 'demo_project' at our current path. Inside the application there would be configuration and 
setup performed for the default components.

You can define specific components to be used:

  $ padrino-gen project demo_project -t rspec -r haml -m rr -s jquery -d datamapper
  
You can also instruct the generator to skip a certain component to avoid using one at all (or to use your own):

  $ padrino-gen project demo_project --test none --renderer none
  
The available components and their default options are listed below:

test::      rspec (default), bacon, shoulda, cucumber, testspec, riot
renderer::  haml  (default), erb
mock::      none  (default), mocha, rr
script::    none  (default), jquery, prototype, mootools, rightjs
orm::       none  (default), mongomapper, mongoid, activerecord, sequel, couchrest

To learn more about the project generator, check out the guide to
{Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators].

=== Sub App Generator

Unlike other ruby frameworks Padrino is principally designed for mounting multiple apps at the same time.

First you need to create a project

  $ padrino-gen project demo_project
  $ cd demo_project

Now you are in demo_project and you can create your apps:

  $ padrino-gen app one
  $ padrino-gen app two

By default these apps are mounted under:

  * /one
  * /two
  
but you can edit config/apps.rb and change it.

To learn more about the subapp generator, check out the guide to
{Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators].

=== Model Generator

Padrino provides generator support for quickly creating new models within your Padrino application. Note that
the models (and migrations) generated are specifically tailored towards the ORM component and testing framework
chosen during application generation. 

Very important to note that model generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. Using model generators 
within an existing application not generated by Padrino will likely not work as expected.

Using the model generator is as simple as:

  $ padrino-gen model User
  
You can also specify desired fields to be contained within your User model:

  $ padrino-gen model User name:string age:integer email:string
  
To learn more about the model generator, check out the guide to
{Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators].

=== Migration Generator

Padrino provides generator for quickly generating new migrations to change or manipulate the database schema.
These migrations generated will be tailored towards the ORM chosen when generating the application.

Very important to note that migration generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. Using migration generators 
within an existing application not generated by Padrino will likely not work as expected.

Using the migration generator is as simple as:

  $ padrino-gen migration AddFieldsToUsers
  $ padrino-gen migration RemoveFieldsFromUsers
  
To learn more about the migration generator, check out the guide to
{Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators].

=== Controller Generator

Padrino provides generator support for quickly creating new controllers within your Padrino application. Note that
the controller tests are generated specifically tailored towards the testing framework chosen 
during application generation. 

Very important to note that controller generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. 

Using the controller generator is as simple as:

  $ padrino-gen controller Admin
  
You can also specify desired actions to be added to your controller:

  $ padrino-gen controller Admin get:index get:new post:create
  
To learn more about the controller generator, check out the guide to
{Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators].

=== Mailer Generator

Padrino provides generator support for quickly creating new mailers within your Padrino application.
Very important to note that mailer generators are intended primarily to work within applications 
created through the Padrino application generator and that follow Padrino conventions. 

Using the mailer generator is as simple as:

  $ padrino-gen mailer UserNotifier

To learn more about the mailer generator, check out the guide to
{Padrino Generators}[http://wiki.github.com/padrino/padrino-framework/generators].

= Application Extensions and Helpers (padrino-helpers)

=== Overview

This component provides a great deal of view helpers related to html markup generation.
There are helpers for generating tags, forms, links, images, and more. Most of the basic
methods should be very familiar to anyone who has used rails view helpers.

=== Output Helpers

Output helpers are a collection of important methods for managing, capturing and displaying output
in various ways and is used frequently to support higher-level helper functions. There are
three output helpers worth mentioning: <tt>content_for</tt>, <tt>capture_html</tt>, and <tt>concat_content</tt> 

The content_for functionality supports capturing content and then rendering this into a different place
such as within a layout. One such popular example is including assets onto the layout from a template:

  # app/views/site/index.erb
  ...
  <% content_for :assets do %>
    <%= stylesheet_link_tag 'index', 'custom' %>
  <% end %>
  ...
  
Added to a template, this will capture the includes from the block and allow them to be yielded into the layout:

  # app/views/layout.erb
  ...
  <head>
    <title>Example</title>
    <%= stylesheet_link_tag 'style' %>
    <%= yield_content :assets %>
  </head>
  ...
  
This will automatically insert the contents of the block (in this case a stylesheet include) into the 
location the content is yielded within the layout.

The capture_html and the concat_content methods allow content to be manipulated and stored for use in building
additional helpers accepting blocks or displaying information in a template. One example is the use of
these in constructing a simplified 'form_tag' helper which accepts a block.

  # form_tag '/register' do ... end
  def form_tag(url, options={}, &block)
    # ... truncated ...
    inner_form_html = capture_html(&block)
    concat_content '<form>' + inner_form_html + '</form>'
  end
  
This will capture the template body passed into the form_tag block and then append the content
to the template through the use of <tt>concat_content</tt>. Note have been built to work for both haml and erb 
templates using the same syntax.

For more information on using output helpers, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].

=== Tag Helpers

Tag helpers are the basic building blocks used to construct html 'tags' within a view template. There
are three major functions for this category: <tt>tag</tt>, <tt>content_tag</tt> and <tt>input_tag</tt>.

The tag and content_tag are for building arbitrary html tags with a name and specified options. If
the tag contains 'content' within then <tt>content_tag</tt> is used. For example:

  tag(:br, :style => ‘clear:both’) => <br style="clear:both" />
  content_tag(:p, "demo", :class => ‘light’) => <p class="light">demo</p>
  
The input_tag is used to build tags that are related to accepting input from the user:

  input_tag :text, :class => "demo" => <input type='text' class='demo' />
  input_tag :password, :value => "secret", :class => "demo"
  
Note that all of these accept html options and result in returning a string containing html tags.

For more information on using tag helpers, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].

=== Asset Helpers

Asset helpers are intended to help insert useful html onto a view template such as 'flash' notices,
hyperlinks, mail_to links, images, stylesheets and javascript. An example of their uses would be on a 
simple view template:

  # app/views/example.haml
  ...
  %head
    = stylesheet_link_tag 'layout'
    = javascript_include_tag 'application'
  %body
    ...
    = flash_tag :notice
    %p= link_to 'Blog', '/blog', :class => 'example'
    %p Mail me at #{mail_to 'fake@faker.com', "Fake Email Link", :cc => "test@demo.com"}
    %p= image_tag 'padrino.png', :width => '35', :class => 'logo'

For more information on using asset helpers, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].
  
=== Form Helpers

Form helpers are the 'standard' form tag helpers you would come to expect when building forms. A simple
example of constructing a non-object form would be:

  - form_tag '/destroy', :class => 'destroy-form', :method => 'delete' do
    = flash_tag(:notice)
    - field_set_tag do
      %p
        = label_tag :username, :class => 'first'
        = text_field_tag :username, :value => params[:username]
      %p
        = label_tag :password, :class => 'first'
        = password_field_tag :password, :value => params[:password]
      %p
        = label_tag :strategy
        = select_tag :strategy, :options => ['delete', 'destroy'], :selected => 'delete'
      %p
        = check_box_tag :confirm_delete
    - field_set_tag(:class => 'buttons') do
      = submit_tag "Remove"

For more information on using form helpers, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].
    
=== FormBuilders

Form builders are full-featured objects allowing the construction of complex object-based forms
using a simple, intuitive syntax.

A form_for using these basic fields might look like:

  - form_for @user, '/register', :id => 'register' do |f|
    = f.error_messages
    %p
      = f.label :username, :caption => "Nickname"
      = f.text_field :username
    %p
      = f.label :email
      = f.text_field :email
    %p
      = f.label :password
      = f.password_field :password
    %p
      = f.label :is_admin, :caption => "Admin User?"
      = f.check_box :is_admin
    %p
      = f.label :color, :caption => "Favorite Color?"
      = f.select :color, :options => ['red', 'black']
    %p
      - fields_for @user.location do |location|
        = location.text_field :street
        = location.text_field :city
    %p
      = f.submit "Create", :class => 'button'
  
There is also an additional StandardFormBuilder which builds on the abstract fields that can be used within a form_for.

A form_for using these standard fields might be:

  - form_for @user, '/register', :id => 'register' do |f|
    = f.error_messages
    = f.text_field_block :name, :caption => "Full name"
    = f.text_field_block :email
    = f.check_box_block  :remember_me
    = f.select_block     :fav_color, :options => ['red', 'blue']
    = f.password_field_block :password
    = f.submit_block "Create", :class => 'button'

and would generate this html (with each input contained in a paragraph and containing a label):

  <form id="register" action="/register" method="post">
    <p><label for="user_name">Full name: </label><input type="text" id="user_name" name="user[name]"></p>
    ...omitted...
    <p><input type="submit" value="Create" class="button"></p>
  </form>

You can also easily build your own FormBuilder which allows for customized fields and behavior.

For more information on using the Padrino form builders, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].

=== Format Helpers

Format helpers are several useful utilities for manipulating the format of text to achieve a goal.
The four format helpers are <tt>escape_html</tt>, <tt>relative_time_ago</tt>, <tt>time_in_words</tt>,
and <tt>js_escape_html</tt>.

The escape_html and js_escape_html function are for taking an html string and escaping certain characters.
<tt>escape_html</tt> will escape ampersands, brackets and quotes to their HTML/XML entities. This is useful
to sanitize user content before displaying this on a template. <tt>js_escape_html</tt> is used for 
passing javascript information from a js template to a javascript function.

  escape_html('<hello>&<goodbye>') # => &lt;hello&gt;&amp;&lt;goodbye&gt;

There is also an alias for escape_html called <tt>h</tt> for even easier usage within templates.

Format helpers also includes a number of useful text manipulation functions such as <tt>simple_format</tt>,
<tt>pluralize</tt>, <tt>word_wrap</tt>, and <tt>truncate</tt>. 

  simple_format("hello\nworld") # => "<p>hello<br/>world</p>"
  pluralize(2, 'person') => '2 people'
  word_wrap('Once upon a time', :line_width => 8) => "Once upon\na time"
  truncate("Once upon a time in a world far far away", :length => 8) => "Once upon..."

These helpers can be invoked from any route or view within your application.

For more information on using the format helpers, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].

=== Render Helpers

This component provides a number of rendering helpers making the process of displaying templates a bit easier. 
This plugin also has support for useful additions such as partials (with support for :collection) for the templating system.

Using render plugin helpers is extremely simple. If you want to render an erb template in your view path:

  render :erb, 'path/to/erb/template'
  
or using haml templates works just as well:

  render :haml, 'path/to/haml/template'
  
There is also a method which renders the first view matching the path and removes the need to define an engine:

  render 'path/to/any/template'
  
Finally, we have the all-important partials support for rendering mini-templates onto a page:

  partial 'photo/_item', :object => @photo, :locals => { :foo => 'bar' }
  partial 'photo/_item', :collection => @photos
  
For more information on using the render and partial helpers, check out the guide for
{Padrino Helpers}[http://wiki.github.com/padrino/padrino-framework/application-helpers].

= Admin Dashboard and Authentication (padrino-admin)

=== Overview

Padrino has a beautiful Admin management dashboard with these features:

Orm Agnostic:: Data Adapters for Datamapper, Activerecord, Mongomapper, Mongoid
Template Agnostic:: Erb and Haml Renderer
Authentication:: Support for Account authentication, Account Permission managment
Scaffold:: You can simply create a new "admin interface" by providing a Model
Access Control:: Supports authentication and role permissions for your application

=== Admin Dashboard Usage

For a complete look at usage of the Admin dashboard functionality, be sure to check out the 
{Padrino Admin}[http://wiki.github.com/padrino/padrino-framework/padrino-admin] guide.

Create a new project:

  $ padrino-gen project demo
  $ cd demo

Create the admin subapplication:

  demo$ padrino-gen admin

Next, follow the admin setup steps:

* configure your <tt>config/database.rb</tt> to connect to the correct data.
* run <tt>padrino rake dm:migrate</tt> # or ar:migrate if you use activerecord
* run <tt>padrino rake seed</tt>

Your admin panel now is ready and you can start your server with <tt>padrino start</tt> and point your browser to <tt>/admin</tt>!

To create a new "scaffold" you need to provide only a Model name to the command:

  demo$ padrino-gen model post --skip-migration # edit your post.rb model and add some fields
  demo$ padrino-gen rake dm:auto:migrate
  demo$ padrino-gen admin_page post
  demo$ padrino start # and go to http://localhost:3000/admin
  
That's all!!

=== Admin Access Control

Padrino Admin use a model Account for manage role, membership and permissions.

For an ecommerce website, usually certain actions require permissions and authentication. This is supported
by the admin access control features:

  class EcommerceSite < Padrino::Application
    enable :authentication
    enable :store_location
    set    :login_page, "/login"

    access_control.roles_for :any do |role|
      role.protect "/customer/orders"
      role.protect "/cart/checkout"
    end
  end

In this example +if+ we visit urls that start with /+customer+/+orders+ or /+cart/checkout+ we will be redirected
to our :+login_page+ "/login". Once we are correctly logged in we can visit these pages.

For a more complete look at using the Admin panel functionality and access features, be sure to check out the 
{Padrino Admin}[http://wiki.github.com/padrino/padrino-framework/padrino-admin] guide.

= Simple Mailer Support (padrino-mailer)

=== Overview

This component uses an enhanced version of the excellent <tt>pony</tt> library (vendored) for a powerful but simple
mailer system within Padrino (and Sinatra). There is full support for using an html content type as well as for file attachments.
The MailerPlugin has many similarities to ActionMailer but is much lighterweight and (arguably) easier to use.

=== Usage

Let's take a look at using the MailerPlugin in an application. By default, MailerPlugin uses the built-in sendmail
functionality on the server. However, smtp is also supported using the following configuration:

    Padrino::Mailer::Base.smtp_settings = {
      :host   => 'smtp.gmail.com',
      :port   => '587',
      :tls    => true,
      :user   => 'user',
      :pass   => 'pass',
      :auth   => :plain
   }

Once those have been defined, the default will become smtp delivery unless overwritten in an individual mail definition.
Next, we should define a custom mailer extended from <tt>Padrino::Mailer::Base</tt>.

  # app/mailers/sample_mailer.rb
  class SampleMailer < Padrino::Mailer::Base
    def registration_email(name, user_email_address)
      from 'admin@site.com'
      to user_email_address
      subject 'Welcome to the site!'
      body    :name => name
      type    'html'                # optional, defaults to plain/text
      charset 'windows-1252'        # optional, defaults to utf-8
      via     :sendmail             # optional, to smtp if defined otherwise sendmail
    end
  end

This defines a mail called '<tt>registration_mail</tt>' with the specified attributes for delivery. The <tt>body</tt> method
is passing the <tt>name</tt> attribute to the body message template which should be defined in
<tt>[views_path]/sample_mailer/registration_email.erb</tt> as shown below:

  # ./views/sample_mailer/registration_email.erb
  This is the body of the email and can access the <%= name %> that was passed in from the mailer definition
  That's all there is to defining the body of the email which can be plain text or html

Once the mailer definition has been completed and the template has been defined, the email can be sent using:

  SampleMailer.deliver(:registration_email, "Bob", "bob@bobby.com")

or if you like the method_missing approach:

  SampleMailer.deliver_registration_email "Bob", 'bob@bobby.com'

And that will then deliver the email according the the configured options. This is really all you need to send emails.

Be sure to check out the 
{Padrino Mailer}[http://wiki.github.com/padrino/padrino-framework/padrino-mailer] guide for more details on usage.

= Painless Page and Fragment Caching (padrino-cache)

Not implemented yet.

== Copyright

Copyright (c) 2010 Padrino. See LICENSE for details.

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
    <title>README.rdoc</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link rel="stylesheet" href="../../css/main.css" type="text/css" media="screen" />
    <script src="../../js/main.js" type="text/javascript" charset="utf-8"></script>
</head>

<body>     
    <table border='0' cellpadding='0' cellspacing='0' width="100%" class='banner'>
      <tr><td>
        <table width="100%" border='0' cellpadding='0' cellspacing='0'><tr>
          <td class="file-title" colspan="2"><span class="file-title-prefix">File</span><br />README.rdoc</td>
          <td align="right">
            <table border='0' cellspacing="0" cellpadding="2">
              <tr>
                <td>Path:</td>
                <td>padrino-helpers/README.rdoc</td>
              </tr>
              <tr>
                <td>Modified:</td>
                <td>Wed Feb 03 00:24:53 +0100 2010</td>
              </tr>
            </table>
          </td></tr>
        </table>
      </td></tr>
    </table><br />

    <div id="bodyContent">
        <div id="content">
    
    <div class="description"><h1>Application Extensions and Helpers (padrino-helpers)</h1>
<h3>Overview</h3>
<p>
This component provides a great deal of view helpers related to html markup
generation. There are helpers for generating tags, forms, links, images,
and more. Most of the basic methods should be very familiar to anyone who
has used rails view helpers.
</p>
<h3>Output Helpers</h3>
<p>
Output helpers are a collection of important methods for managing,
capturing and displaying output in various ways and is used frequently to
support higher-level helper functions. There are three output helpers worth
mentioning: <tt>content_for</tt>, <tt>capture_html</tt>, and
<tt>concat_content</tt>
</p>
<p>
The content_for functionality supports capturing content and then rendering
this into a different place such as within a layout. One such popular
example is including assets onto the layout from a template:
</p>
<pre>
  # app/views/site/index.erb
  ...
  &lt;% content_for :assets do %&gt;
    &lt;%= stylesheet_link_tag 'index', 'custom' %&gt;
  &lt;% end %&gt;
  ...
</pre>
<p>
Added to a template, this will capture the includes from the block and
allow them to be yielded into the layout:
</p>
<pre>
  # app/views/layout.erb
  ...
  &lt;head&gt;
    &lt;title&gt;Example&lt;/title&gt;
    &lt;%= stylesheet_link_tag 'style' %&gt;
    &lt;%= yield_content :assets %&gt;
  &lt;/head&gt;
  ...
</pre>
<p>
This will automatically insert the contents of the block (in this case a
stylesheet include) into the location the content is yielded within the
layout.
</p>
<p>
The capture_html and the concat_content methods allow content to be
manipulated and stored for use in building additional helpers accepting
blocks or displaying information in a template. One example is the use of
these in constructing a simplified &#8216;form_tag&#8217; helper which
accepts a block.
</p>
<pre>
  # form_tag '/register' do ... end
  def form_tag(url, options={}, &amp;block)
    # ... truncated ...
    inner_form_html = capture_html(&amp;block)
    concat_content '&lt;form&gt;' + inner_form_html + '&lt;/form&gt;'
  end
</pre>
<p>
This will capture the template body passed into the form_tag block and then
append the content to the template through the use of
<tt>concat_content</tt>. Note have been built to work for both haml and erb
templates using the same syntax.
</p>
<p>
The list of defined helpers in the &#8216;output helpers&#8217; category:
</p>
<ul>
<li><tt>content_for(key, &amp;block)</tt>

<ul>
<li>Capture a block of content to be rendered at a later time.

</li>
<li><tt>content_for(:head) { ...content... }</tt>

</li>
<li>Also supports arguments passed to the content block

</li>
<li><tt>content_for(:head) { |param1, param2| ...content... }</tt>

</li>
</ul>
</li>
<li><tt>yield_content(key, *args)</tt>

<ul>
<li>Render the captured content blocks for a given key.

</li>
<li><tt>yield_content :head</tt>

</li>
<li>Also supports arguments yielded to the content block

</li>
<li><tt>yield_content :head, param1, param2</tt>

</li>
</ul>
</li>
<li><tt>capture_html(*args, &amp;block)</tt>

<ul>
<li>Captures the html from a block of template code for erb or haml

</li>
<li><tt>capture_html(&amp;block)</tt> => &#8220;&#8230;html...&#8220;

</li>
</ul>
</li>
<li><tt>concat_content(text=&quot;&quot;)</tt>

<ul>
<li>Outputs the given text to the templates buffer directly in erb or haml

</li>
<li><tt>concat_content(&quot;This will be output to the template buffer in erb
or haml&quot;)</tt>

</li>
</ul>
</li>
</ul>
<h3>Tag Helpers</h3>
<p>
Tag helpers are the basic building blocks used to construct html
&#8216;tags&#8217; within a view template. There are three major functions
for this category: <tt>tag</tt>, <tt>content_tag</tt> and
<tt>input_tag</tt>.
</p>
<p>
The tag and content_tag are for building arbitrary html tags with a name
and specified options. If the tag contains &#8216;content&#8217; within
then <tt>content_tag</tt> is used. For example:
</p>
<pre>
  tag(:br, :style =&gt; ‘clear:both’) =&gt; &lt;br style=&quot;clear:both&quot; /&gt;
  content_tag(:p, &quot;demo&quot;, :class =&gt; ‘light’) =&gt; &lt;p class=&quot;light&quot;&gt;demo&lt;/p&gt;
</pre>
<p>
The input_tag is used to build tags that are related to accepting input
from the user:
</p>
<pre>
  input_tag :text, :class =&gt; &quot;demo&quot; =&gt; &lt;input type='text' class='demo' /&gt;
  input_tag :password, :value =&gt; &quot;secret&quot;, :class =&gt; &quot;demo&quot;
</pre>
<p>
Note that all of these accept html options and result in returning a string
containing html tags.
</p>
<p>
The list of defined helpers in the &#8216;tag helpers&#8217; category:
</p>
<ul>
<li><tt>tag(name, options={})</tt>

<ul>
<li>Creates an html tag with the given name and options

</li>
<li><tt>tag(:br, :style =&gt; 'clear:both')</tt> => <br
style=&#8220;clear:both&#8221; />

</li>
<li><tt>tag(:p, :content =&gt; &quot;demo&quot;, :class =&gt; 'large')</tt> =>
<p class=&#8220;large&#8221;>demo</p>

</li>
</ul>
</li>
<li><tt>content_tag(name, content, options={})</tt>

<ul>
<li>Creates an html tag with given name, content and options

</li>
<li><tt>content_tag(:p, &quot;demo&quot;, :class =&gt; 'light')</tt> => <p
class=&#8220;light&#8221;>demo</p>

</li>
<li><tt>content_tag(:p, :class =&gt; 'dark') { ...content... }</tt> => <p
class=&#8220;dark&#8221;>&#8230;content...</p>

</li>
</ul>
</li>
<li><tt>input_tag(type, options = {})</tt>

<ul>
<li>Creates an html input field with given type and options

</li>
<li><tt>input_tag :text, :class =&gt; &quot;demo&quot;</tt>

</li>
<li><tt>input_tag :password, :value =&gt; &quot;secret&quot;, :class =&gt;
&quot;demo&quot;</tt>

</li>
</ul>
</li>
</ul>
<h3>Asset Helpers</h3>
<p>
Asset helpers are intended to help insert useful html onto a view template
such as &#8216;flash&#8217; notices, hyperlinks, mail_to links, images,
stylesheets and javascript. An example of their uses would be on a simple
view template:
</p>
<pre>
  # app/views/example.haml
  ...
  %head
    = stylesheet_link_tag 'layout'
    = javascript_include_tag 'application'
  %body
    ...
    = flash_tag :notice
    %p= link_to 'Blog', '/blog', :class =&gt; 'example'
    %p Mail me at #{mail_to 'fake@faker.com', &quot;Fake Email Link&quot;, :cc =&gt; &quot;test@demo.com&quot;}
    %p= image_tag 'padrino.png', :width =&gt; '35', :class =&gt; 'logo'
</pre>
<p>
The list of defined helpers in the &#8216;asset helpers&#8217; category:
</p>
<ul>
<li><tt>flash_tag(kind, options={})</tt>

<ul>
<li>Creates a div to display the flash of given type if it exists

</li>
<li><tt>flash_tag(:notice, :class =&gt; 'flash', :id =&gt; 'flash-notice')</tt>

</li>
</ul>
</li>
<li><tt>link_to(*args, &amp;block)</tt>

<ul>
<li>Creates a link element with given name, url and options

</li>
<li><tt>link_to 'click me', '/dashboard', :class =&gt; 'linky'</tt>

</li>
<li><tt>link_to 'click me', '/dashboard', :class =&gt; 'linky', :if =&gt;
@foo.present?</tt>

</li>
<li><tt>link_to 'click me', '/dashboard', :class =&gt; 'linky', :unless =&gt;
@foo.blank?</tt>

</li>
<li><tt>link_to 'click me', '/dashboard', :class =&gt; 'linky', :unless =&gt;
:current</tt>

</li>
<li><tt>link_to('/dashboard', :class =&gt; 'blocky') { ...content... }</tt>

</li>
</ul>
</li>
<li><tt>mail_to(email, caption=nil, mail_options={})</tt>

<ul>
<li>Creates a mailto link tag to the specified email_address

</li>
<li><tt>mail_to &quot;me@demo.com&quot;</tt>

</li>
<li><tt>mail_to &quot;me@demo.com&quot;, &quot;My Email&quot;, :subject =&gt;
&quot;Feedback&quot;, :cc =&gt; 'test@demo.com'</tt>

</li>
</ul>
</li>
<li><tt>image_tag(url, options={})</tt>

<ul>
<li>Creates an image element with given url and options

</li>
<li><tt>image_tag('icons/avatar.png')</tt>

</li>
</ul>
</li>
<li><tt>stylesheet_link_tag(*sources)</tt>

<ul>
<li>Returns a stylesheet link tag for the sources specified as arguments

</li>
<li><tt>stylesheet_link_tag 'style', 'application', 'layout'</tt>

</li>
</ul>
</li>
<li><tt>javascript_include_tag(*sources)</tt>

<ul>
<li>Returns an html script tag for each of the sources provided.

</li>
<li><tt>javascript_include_tag 'application', 'special'</tt>

</li>
</ul>
</li>
</ul>
<h3>Form Helpers</h3>
<p>
Form helpers are the &#8216;standard&#8217; form tag helpers you would come
to expect when building forms. A simple example of constructing a
non-object form would be:
</p>
<pre>
  - form_tag '/destroy', :class =&gt; 'destroy-form', :method =&gt; 'delete' do
    = flash_tag(:notice)
    - field_set_tag do
      %p
        = label_tag :username, :class =&gt; 'first'
        = text_field_tag :username, :value =&gt; params[:username]
      %p
        = label_tag :password, :class =&gt; 'first'
        = password_field_tag :password, :value =&gt; params[:password]
      %p
        = label_tag :strategy
        = select_tag :strategy, :options =&gt; ['delete', 'destroy'], :selected =&gt; 'delete'
      %p
        = check_box_tag :confirm_delete
    - field_set_tag(:class =&gt; 'buttons') do
      = submit_tag &quot;Remove&quot;
</pre>
<p>
The list of defined helpers in the &#8216;form helpers&#8217; category:
</p>
<ul>
<li><tt>form_tag(url, options={}, &amp;block)</tt>

<ul>
<li>Constructs a form without object based on options

</li>
<li>Supports form methods &#8216;put&#8217; and &#8216;delete&#8217; through
hidden field

</li>
<li><tt>form_tag('/register', :class =&gt; 'example') { ... }</tt>

</li>
</ul>
</li>
<li><tt>field_set_tag(*args, &amp;block)</tt>

<ul>
<li>Constructs a field_set to group fields with given options

</li>
<li><tt>field_set_tag(:class =&gt; 'office-set') { }</tt>

</li>
<li><tt>field_set_tag(&quot;Office&quot;, :class =&gt; 'office-set') { }</tt>

</li>
</ul>
</li>
<li><tt>error_messages_for(:record, options={})</tt>

<ul>
<li>Constructs list html for the errors for a given object

</li>
<li><tt>error_messages_for :user</tt>

</li>
</ul>
</li>
<li><tt>label_tag(name, options={}, &amp;block)</tt>

<ul>
<li>Constructs a label tag from the given options

</li>
<li><tt>label_tag :username, :class =&gt; 'long-label'</tt>

</li>
<li><tt>label_tag(:username, :class =&gt; 'blocked-label') { ... }</tt>

</li>
</ul>
</li>
<li><tt>hidden_field_tag(name, options={})</tt>

<ul>
<li>Constructs a hidden field input from the given options

</li>
<li><tt>hidden_field_tag :session_key, :value =&gt; 'secret'</tt>

</li>
</ul>
</li>
<li><tt>text_field_tag(name, options={})</tt>

<ul>
<li>Constructs a text field input from the given options

</li>
<li><tt>text_field_tag :username, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>text_area_tag(name, options={})</tt>

<ul>
<li>Constructs a text area input from the given options

</li>
<li><tt>text_area_tag :username, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>password_field_tag(name, options={})</tt>

<ul>
<li>Constructs a password field input from the given options

</li>
<li><tt>password_field_tag :password, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>check_box_tag(name, options={})</tt>

<ul>
<li>Constructs a checkbox input from the given options

</li>
<li><tt>check_box_tag :remember_me, :checked =&gt; true</tt>

</li>
</ul>
</li>
<li><tt>radio_button_tag(name, options={})</tt>

<ul>
<li>Constructs a radio button input from the given options

</li>
<li><tt>radio_button_tag :gender, :value =&gt; 'male'</tt>

</li>
</ul>
</li>
<li><tt>select_tag(name, settings={})</tt>

<ul>
<li>Constructs a select tag with options from the given settings

</li>
<li><tt>select_tag(:favorite_color, :options =&gt; ['1', '2', '3'], :selected
=&gt; '1')</tt>

</li>
<li><tt>select_tag(:more_color, :options =&gt; [['label', '1'], ['label2',
'2']])</tt>

</li>
<li><tt>select_tag(:multiple_color, :options =&gt; [...], :multiple =&gt;
true)</tt>

</li>
</ul>
</li>
<li><tt>file_field_tag(name, options={})</tt>

<ul>
<li>Constructs a file field input from the given options

</li>
<li><tt>file_field_tag :photo, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>submit_tag(caption, options={})</tt>

<ul>
<li>Constructs a submit button from the given options

</li>
<li><tt>submit_tag &quot;Create&quot;, :class =&gt; 'success'</tt>

</li>
</ul>
</li>
<li><tt>button_tag(caption, options={})</tt>

<ul>
<li>Constructs an input (type => &#8216;button&#8217;) from the given options

</li>
<li><tt>button_tag &quot;Cancel&quot;, :class =&gt; 'clear'</tt>

</li>
</ul>
</li>
<li><tt>image_submit_tag(source, options={})</tt>

<ul>
<li>Constructs an image submit button from the given options

</li>
<li><tt>image_submit_tag &quot;submit.png&quot;, :class =&gt; 'success'</tt>

</li>
</ul>
</li>
</ul>
<h3>FormBuilders</h3>
<p>
Form builders are full-featured objects allowing the construction of
complex object-based forms using a simple, intuitive syntax.
</p>
<p>
A form_for using these basic fields might look like:
</p>
<pre>
  - form_for @user, '/register', :id =&gt; 'register' do |f|
    = f.error_messages
    %p
      = f.label :username, :caption =&gt; &quot;Nickname&quot;
      = f.text_field :username
    %p
      = f.label :email
      = f.text_field :email
    %p
      = f.label :password
      = f.password_field :password
    %p
      = f.label :is_admin, :caption =&gt; &quot;Admin User?&quot;
      = f.check_box :is_admin
    %p
      = f.label :color, :caption =&gt; &quot;Favorite Color?&quot;
      = f.select :color, :options =&gt; ['red', 'black']
    %p
      - fields_for @user.location do |location|
        = location.text_field :street
        = location.text_field :city
    %p
      = f.submit &quot;Create&quot;, :class =&gt; 'button'
</pre>
<p>
The list of defined helpers in the &#8216;form builders&#8217; category:
</p>
<ul>
<li><tt>form_for(object, url, settings={}, &amp;block)</tt>

<ul>
<li>Constructs a form using given or default form_builder

</li>
<li>Supports form methods &#8216;put&#8217; and &#8216;delete&#8217; through
hidden field

</li>
<li>Defaults to StandardFormBuilder but you can easily create your own!

</li>
<li><tt>form_for(@user, '/register', :id =&gt; 'register') { |f|
...field-elements... }</tt>

</li>
<li><tt>form_for(:user, '/register', :id =&gt; 'register') { |f|
...field-elements... }</tt>

</li>
</ul>
</li>
<li><tt>fields_for(object, settings={}, &amp;block)</tt>

<ul>
<li>Constructs fields for a given object for use in an existing form

</li>
<li>Defaults to StandardFormBuilder but you can easily create your own!

</li>
<li><tt>fields_for @user.assignment do |assignment| ... end</tt>

</li>
<li><tt>fields_for :assignment do |assigment| ... end</tt>

</li>
</ul>
</li>
</ul>
<p>
The following are fields provided by AbstractFormBuilder that can be used
within a form_for or fields_for:
</p>
<ul>
<li><tt>error_messages(options={})</tt>

<ul>
<li>Displays list html for the errors on form object

</li>
<li><tt>f.errors_messages</tt>

</li>
</ul>
</li>
<li><tt>label(field, options={})</tt>

<ul>
<li><tt>f.label :name, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>text_field(field, options={})</tt>

<ul>
<li><tt>f.text_field :username, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>check_box(field, options={})</tt>

<ul>
<li>Uses hidden field to provide a &#8216;unchecked&#8217; value for field

</li>
<li><tt>f.check_box :remember_me, :uncheck_value =&gt; 'false'</tt>

</li>
</ul>
</li>
<li><tt>radio_button(field, options={})</tt>

<ul>
<li><tt>f.radio_button :gender, :value =&gt; 'male'</tt>

</li>
</ul>
</li>
<li><tt>hidden_field(field, options={})</tt>

<ul>
<li><tt>f.hidden_field :session_id, :class =&gt; 'hidden'</tt>

</li>
</ul>
</li>
<li><tt>text_area(field, options={})</tt>

<ul>
<li><tt>f.text_area :summary, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>password_field(field, options={})</tt>

<ul>
<li><tt>f.password_field :secret, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>file_field(field, options={})</tt>

<ul>
<li><tt>f.file_field :photo, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>select(field, options={})</tt>

<ul>
<li><tt>f.select(:state, :options =&gt; ['California', 'Texas',
'Wyoming'])</tt>

</li>
<li><tt>f.select(:state, :collection =&gt; @states, :fields =&gt; [:name,
:id])</tt>

</li>
<li><tt>f.select(:state, :options =&gt; [...], :include_blank =&gt; true)</tt>

</li>
</ul>
</li>
<li><tt>submit(caption, options={})</tt>

<ul>
<li><tt>f.submit &quot;Update&quot;, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
<li><tt>image_submit(source, options={})</tt>

<ul>
<li><tt>f.image_submit &quot;submit.png&quot;, :class =&gt; 'long'</tt>

</li>
</ul>
</li>
</ul>
<p>
There is also an additional StandardFormBuilder which builds on the
abstract fields that can be used within a form_for.
</p>
<p>
A form_for using these standard fields might be:
</p>
<pre>
  - form_for @user, '/register', :id =&gt; 'register' do |f|
    = f.error_messages
    = f.text_field_block :name, :caption =&gt; &quot;Full name&quot;
    = f.text_field_block :email
    = f.check_box_block  :remember_me
    = f.select_block     :fav_color, :options =&gt; ['red', 'blue']
    = f.password_field_block :password
    = f.submit_block &quot;Create&quot;, :class =&gt; 'button'
</pre>
<p>
and would generate this html (with each input contained in a paragraph and
containing a label):
</p>
<pre>
  &lt;form id=&quot;register&quot; action=&quot;/register&quot; method=&quot;post&quot;&gt;
    &lt;p&gt;&lt;label for=&quot;user_name&quot;&gt;Full name: &lt;/label&gt;&lt;input type=&quot;text&quot; id=&quot;user_name&quot; name=&quot;user[name]&quot;&gt;&lt;/p&gt;
    ...omitted...
    &lt;p&gt;&lt;input type=&quot;submit&quot; value=&quot;Create&quot; class=&quot;button&quot;&gt;&lt;/p&gt;
  &lt;/form&gt;
</pre>
<p>
The following are fields provided by StandardFormBuilder that can be used
within a form_for or fields_for:
</p>
<ul>
<li><tt>text_field_block(field, options={}, label_options={})</tt>

<ul>
<li><tt>text_field_block(:nickname, :class =&gt; 'big', :caption =&gt;
&quot;Username&quot;)</tt>

</li>
</ul>
</li>
<li><tt>text_area_block(field, options={}, label_options={})</tt>

<ul>
<li><tt>text_area_block(:about, :class =&gt; 'big')</tt>

</li>
</ul>
</li>
<li><tt>password_field_block(field, options={}, label_options={})</tt>

<ul>
<li><tt>password_field_block(:code, :class =&gt; 'big')</tt>

</li>
</ul>
</li>
<li><tt>file_field_block(field, options={}, label_options={})</tt>

<ul>
<li><tt>file_field_block(:photo, :class =&gt; 'big')</tt>

</li>
</ul>
</li>
<li><tt>check_box_block(field, options={}, label_options={})</tt>

<ul>
<li><tt>check_box_block(:remember_me, :class =&gt; 'big')</tt>

</li>
</ul>
</li>
<li><tt>select_block(field, options={}, label_options={})</tt>

<ul>
<li><tt>select_block(:country, :option =&gt; ['USA', 'Canada'])</tt>

</li>
</ul>
</li>
<li><tt>submit_block(caption, options={})</tt>

<ul>
<li><tt>submit_block(:username, :class =&gt; 'big')</tt>

</li>
</ul>
</li>
<li><tt>image_submit_block(source, options={})</tt>

<ul>
<li><tt>image_submit_block('submit.png', :class =&gt; 'big')</tt>

</li>
</ul>
</li>
</ul>
<p>
You can also easily build your own FormBuilder which allows for customized
fields and behavior:
</p>
<pre>
  class MyCustomFormBuilder &lt; AbstractFormBuilder
    # Here we have access to a number of useful variables
    #
    #   * template  (use this to invoke any helpers)(ex. template.hidden_field_tag(...))
    #   * object    (the record for this form) (ex. object.valid?)
    #   * object_name (object's underscored type) (ex. object_name =&gt; 'admin_user')
    #
    # We also have access to self.field_types =&gt; [:text_field, :text_area, ...]
    # In addition, we have access to all the existing field tag helpers (text_field, hidden_field, file_field, ...)
  end
</pre>
<p>
Once a custom builder is defined, any call to form_for can use the new
builder:
</p>
<pre>
  - form_for @user, '/register', :builder =&gt; 'MyCustomFormBuilder', :id =&gt; 'register' do |f|
    ...fields here...
</pre>
<p>
The form builder can even be made into the default builder when form_for is
invoked:
</p>
<pre>
  # anywhere in the Padrino or Sinatra application
  set :default_builder, 'MyCustomFormBuilder'
</pre>
<p>
And there you have it, a fairly complete form builder solution for <a
href="../../classes/Padrino.html">Padrino</a> (and Sinatra). I hope to
create or merge in an even better &#8216;default&#8217; form_builder in the
near future.
</p>
<h3>Format Helpers</h3>
<p>
Format helpers are several useful utilities for manipulating the format of
text to achieve a goal. The four format helpers are <tt>escape_html</tt>,
<tt>relative_time_ago</tt>, <tt>time_in_words</tt>, and
<tt>js_escape_html</tt>.
</p>
<p>
The escape_html and js_escape_html function are for taking an html string
and escaping certain characters. <tt>escape_html</tt> will escape
ampersands, brackets and quotes to their HTML/XML entities. This is useful
to sanitize user content before displaying this on a template.
<tt>js_escape_html</tt> is used for passing javascript information from a
js template to a javascript function.
</p>
<pre>
  escape_html('&lt;hello&gt;&amp;&lt;goodbye&gt;') # =&gt; &amp;lt;hello&amp;gt;&amp;amp;&amp;lt;goodbye&amp;gt;
</pre>
<p>
There is also an alias for escape_html called <tt>h</tt> for even easier
usage within templates.
</p>
<p>
Format helpers also includes a number of useful text manipulation functions
such as <tt>simple_format</tt>, <tt>pluralize</tt>, <tt>word_wrap</tt>, and
<tt>truncate</tt>.
</p>
<pre>
  simple_format(&quot;hello\nworld&quot;) # =&gt; &quot;&lt;p&gt;hello&lt;br/&gt;world&lt;/p&gt;&quot;
  pluralize(2, 'person') =&gt; '2 people'
  word_wrap('Once upon a time', :line_width =&gt; 8) =&gt; &quot;Once upon\na time&quot;
  truncate(&quot;Once upon a time in a world far far away&quot;, :length =&gt; 8) =&gt; &quot;Once upon...&quot;
</pre>
<p>
These helpers can be invoked from any route or view within your
application.
</p>
<p>
The list of defined helpers in the &#8216;format helpers&#8217; category:
</p>
<ul>
<li><tt>simple_format(text, html_options)</tt>

<ul>
<li>Returns text transformed into HTML using simple formatting rules.

</li>
<li><tt>simple_format(&quot;hellonworld&quot;)</tt> =>
&#8220;<p>hello<br/>world</p>&#8220;

</li>
</ul>
</li>
<li><tt>pluralize(count, singular, plural = nil)</tt>

<ul>
<li>Attempts to pluralize the singular word unless count is 1.

</li>
<li><tt>pluralize(2, 'person')</tt> => &#8216;2 people&#8217;

</li>
</ul>
</li>
<li><tt>word_wrap(text, *args)</tt>

<ul>
<li>Wraps the text into lines no longer than line_width width.

</li>
<li><tt>word_wrap('Once upon a time', :line_width =&gt; 8)</tt> => &#8220;Once
uponna time&#8220;

</li>
</ul>
</li>
<li><tt>truncate(text, *args)</tt>

<ul>
<li>Truncates a given text after a given :length if text is longer than :length
(defaults to 30).

</li>
<li><tt>truncate(&quot;Once upon a time in a world far far away&quot;, :length
=&gt; 8)</tt> => &#8220;Once upon...&#8220;

</li>
</ul>
</li>
<li><tt>escape_html</tt> (alias <tt>h</tt> and <tt>h!</tt>)

<ul>
<li>(from RackUtils) Escape ampersands, brackets and quotes to their HTML/XML
entities.

</li>
</ul>
</li>
<li><tt>relative_time_ago(date)</tt>

<ul>
<li>Returns relative time in words referencing the given date

</li>
<li><tt>relative_time_ago(2.days.ago)</tt> => &#8220;2 days&#8220;

</li>
<li><tt>relative_time_ago(5.minutes.ago)</tt> => &#8220;5 minutes&#8220;

</li>
<li><tt>relative_time_ago(2800.days.ago)</tt> => &#8220;over 7 years&#8220;

</li>
</ul>
</li>
<li><tt>time_in_words(date)</tt>

<ul>
<li>Returns relative time in the past or future using appropriate date format

</li>
<li><tt>time_in_words(2.days.ago)</tt> => &#8220;2 days ago&#8220;

</li>
<li><tt>time_in_words(100.days.ago)</tt> => &#8220;Tuesday, July 21&#8220;

</li>
<li><tt>time_in_words(1.day.from_now)</tt> => &#8220;tomorrow&#8220;

</li>
</ul>
</li>
<li><tt>js_escape_html(html_content)</tt>

<ul>
<li>Escapes html to allow passing information to javascript. Used for passing
data inside an ajax .js.erb template

</li>
<li><tt>js_escape_html(&quot;&lt;h1&gt;Hey&lt;/h1&gt;&quot;)</tt>

</li>
</ul>
</li>
</ul>
<p>
See the wiki article for additional information: <&#8230;WIKI&#8230;>
</p>
<h3>Render Helpers</h3>
<p>
This component provides a number of rendering helpers making the process of
displaying templates a bit easier. This plugin also has support for useful
additions such as partials (with support for :collection) for the
templating system.
</p>
<p>
Using render plugin helpers is extremely simple. If you want to render an
erb template in your view path:
</p>
<pre>
  erb_template 'path/to/my/template'
</pre>
<p>
or using haml templates works just as well:
</p>
<pre>
  haml_template 'path/to/haml/template'
</pre>
<p>
There is also a method which renders the first view matching the path and
removes the need to define an engine:
</p>
<pre>
  render_template 'path/to/any/template'
</pre>
<p>
It is worth noting these are mostly for convenience. With nested view file
paths in Sinatra, this becomes tiresome:
</p>
<pre>
  haml :&quot;the/path/to/file&quot;
  erb &quot;/path/to/file&quot;.to_sym
</pre>
<p>
Finally, we have the all-important partials support for rendering
mini-templates onto a page:
</p>
<pre>
  partial 'photo/_item', :object =&gt; @photo, :locals =&gt; { :foo =&gt; 'bar' }
  partial 'photo/_item', :collection =&gt; @photos
</pre>
<p>
This works as you would expect and also supports the collection counter
inside the partial <tt>item_counter</tt>
</p>
<pre>
  # /views/photo/_item.haml
  # Access to collection counter with &lt;partial_name&gt;_counter i.e item_counter
  # Access the object with the partial_name i.e item
</pre>
<p>
The list of defined helpers in the &#8216;render helpers&#8217; category:
</p>
<ul>
<li><tt>erb_template(template_path, options={})</tt>

<ul>
<li>Renders a erb template based on the given path

</li>
<li><tt>erb_template 'users/new'</tt>

</li>
</ul>
</li>
<li><tt>haml_template(template_path, options={})</tt>

<ul>
<li>Renders a haml template based on the given path

</li>
<li><tt>haml_template 'users/new'</tt>

</li>
</ul>
</li>
<li><tt>render_template(template_path, options={})</tt>

<ul>
<li>Renders the first detected template based on the given path

</li>
<li><tt>render_template 'users/new'</tt>

</li>
<li><tt>render_template 'users/index', :template_engine =&gt; 'haml'</tt>

</li>
</ul>
</li>
<li><tt>partial(template, *args)</tt>

<ul>
<li>Renders the html related to the partial template for object or collection

</li>
<li><tt>partial 'photo/_item', :object =&gt; @photo, :locals =&gt; { :foo =&gt;
'bar' }</tt>

</li>
<li><tt>partial 'photo/_item', :collection =&gt; @photos</tt>

</li>
</ul>
</li>
</ul>
<p>
See the wiki article for additional information: <&#8230;WIKI&#8230;>
</p>
<h2>Copyright</h2>
<p>
Copyright &#169; 2010 <a href="../../classes/Padrino.html">Padrino</a>. See
LICENSE for details.
</p>
</div>
    

    

    
    

    
    

    

    

    

    

    

    
</div>
    </div>
  </body>
</html>
module Padrino
  module ExtJs
    # Return column config, and store config/data for ExtJS ColumnModel and Store
    # 
    #   Examples:
    # 
    #     # app/controllers/backend/debtors_controller.rb
    #     def index
    #       @column_store = column_store_for Debtor do |cm|
    #         cm.add :id          
    #         cm.add "full_name_or_company.upcase",   "Full Name",      :sortable => true, :dataIndex => :company
    #         cm.add :surname  # Header will be autogenerated
    #         cm.add :email,                          "Email",          :sortable => true
    #         cm.add :piva,                           "Piva",           :sortable => true
    #         cm.add :created_at,                     "Creato il",      :sortable => true, :renderer => :date, :align => :right
    #         cm.add :updated_at,                     "Aggiornato il",  :sortable => true, :renderer => :datetime, :align => :right
    #       end
    #     
    #       respond_to do |format|
    #         format.js 
    #         format.json do
    #           render :json => @column_store.store_data(params)
    #           
    #           # or you can manually do:
    #             # debtors           = Debtor.search(params)
    #             # debtors_count     = debtors.size
    #             # debtors_paginated = debtors.paginate(params)
    #             # render :json => { :results => @column_store.store_data_from(debtors_paginated), :count => debtors_count }
    #         end
    #       end
    #     end
    # 
    #     # app/views/backend/index.rjs
    #     page.grid do |grid|
    #       grid.id "debtors-grid" # If you don't set this columns are not saved in cookies
    #       grid.title "List al debtors"
    #       grid.base_path "/backend/debtors"
    #       grid.forgery_protection_token request_forgery_protection_token
    #       grid.authenticity_token form_authenticity_token
    #       grid.tbar  :default
    #       grid.store do |store|
    #         store.url "/backend/debtors.json"
    #         store.fields @column_store.store_fields
    #       end
    #       grid.columns do |columns|
    #         columns.fields @column_store.column_fields
    #       end
    #       grid.bbar  :store => grid.get_store, :pageSize => params[:limit] # Remember to add after defining store!
    #     end
    #
    module Controller
      def self.column_store_for(model, config)
        ColumnStore.new(model, config)
      end

      class ColumnStore #:nodoc:
        attr_reader :data

        def initialize(model, config) #:nodoc
          @model = model
          @data = config["columns"].map do |column|

            # Reformat our config
            column["header"]     ||= column["method"].to_s
            column["dataIndex"]  ||= column["method"]
            column["sortable"]   ||= column["sortable"].nil? ? true : column["sortable"]
            column["header"]       = @model.human_attribute_name(column["header"]) # try to translate with I18n the column name

            # Try to reformat the dataIndex
            data_indexes = Array(column["dataIndex"]).collect do |data_index|
              if data_index =~ /\./ # if we have some like categories.names we use this
                cols = data_index.split(".")
                column["name"] ||= cols[0] + "[" + cols[1..-1].join("][") + "]" # accounts.name will be => accounts[name]
              else
                column["name"] ||= "#{@model.table_name.singularize}[#{data_index}]"
                data_index = "#{@model.table_name}.#{data_index}"
              end
              data_index
            end

            # Now we join our data indexes
            column["dataIndex"] = data_indexes.compact.uniq.join(",")

            # Reformat mapping like a div id
            column["mapping"] ||= column["name"].sub(/\[/,"_").sub(/\]$/, "").sub(/\]\[/,"_")

            # Now is necessary for our columns an ID
            # TODO: check duplicates here
            column["id"] = column["mapping"]
            

            # Finally we can return our column
            column
          end
        end

        # Return an array config for build an Ext.grid.ColumnModel() config
        def column_fields
          @data.map do |data|
            data.delete("method")
            data.delete("mapping")
            data
          end
        end

        # Return an array config for build an Ext.data.GroupingStore()
        def store_fields
          @data.map do |data|
            hash = { :name => data["dataIndex"], :mapping => data["mapping"] }
            hash.merge!(:type => data["renderer"]) if  data["renderer"] && [:date, :datetime, :time_to_date].include?(data["renderer"])
            hash
          end
        end

        # Return data for a custom collection for the ExtJS Ext.data.GroupingStore() json
        def store_data_from(collection)
          collection.map do |c|
            @data.dup.inject({ "id" => c.id }) do |options, data|
              options[data["mapping"]] = (c.instance_eval(data["method"]) rescue I18n.t("padrino.admin.labels.not_found"))
              options
            end
          end
        end

        # Return a searched and paginated data collection for the ExtJS Ext.data.GroupingStore() json
        # You can pass options like:
        # 
        #   Examples
        #   
        #     store_data(params, :conditions => "found = 1")
        #     store_data(params, :include => :posts)
        # 
        def store_data(params={}, options={})
          # Some can tell me that this method made two identical queries one for count one for paginate.
          # We don't use the select count because in some circumstances require much time than select *.
          collection           = @model.all(options).ext_search(params)
          collection_count     = collection.length
          collection_paginated = collection.ext_paginate(params)
          { :results => store_data_from(collection_paginated), :count => collection_count }
        end

      end
    end
  end
end
module Padrino
  module ExtJs
    # Return column config, and store config/data for ExtJS ColumnModel and Store
    # 
    #   Examples:
    # 
    #     # app/controllers/backend/debtors_controller.rb
    #     def index
    #       @column_store = column_store_for Debtor do |cm|
    #         cm.add :id          
    #         cm.add "full_name_or_company.upcase",   "Full Name",      :sortable => true, :dataIndex => :company
    #         cm.add :surname  # Header will be autogenerated
    #         cm.add :email,                          "Email",          :sortable => true
    #         cm.add :piva,                           "Piva",           :sortable => true
    #         cm.add :created_at,                     "Creato il",      :sortable => true, :renderer => :date, :align => :right
    #         cm.add :updated_at,                     "Aggiornato il",  :sortable => true, :renderer => :datetime, :align => :right
    #       end
    #     
    #       respond_to do |format|
    #         format.js 
    #         format.json do
    #           render :json => @column_store.store_data(params)
    #           
    #           # or you can manually do:
    #             # debtors           = Debtor.search(params)
    #             # debtors_count     = debtors.size
    #             # debtors_paginated = debtors.paginate(params)
    #             # render :json => { :results => @column_store.store_data_from(debtors_paginated), :count => debtors_count }
    #         end
    #       end
    #     end
    # 
    #     # app/views/backend/index.rjs
    #     page.grid do |grid|
    #       grid.id "debtors-grid" # If you don't set this columns are not saved in cookies
    #       grid.title "List al debtors"
    #       grid.base_path "/backend/debtors"
    #       grid.forgery_protection_token request_forgery_protection_token
    #       grid.authenticity_token form_authenticity_token
    #       grid.tbar  :default
    #       grid.store do |store|
    #         store.url "/backend/debtors.json"
    #         store.fields @column_store.store_fields
    #       end
    #       grid.columns do |columns|
    #         columns.fields @column_store.column_fields
    #       end
    #       grid.bbar  :store => grid.get_store, :pageSize => params[:limit] # Remember to add after defining store!
    #     end
    #
    module Controller
      def self.column_store_for(model, &block)
        ColumnStore.new(model, &block)
      end

      class ColumnStore #:nodoc:
        attr_reader :data

        def initialize(model, &block) #:nodoc
          @model = model
          @data = []
          yield self
        end

        # Method for add columns to the Column Model
        def add(*args)

          # First we need to check that our method is a symbol
          raise Padrino::ExtJs::ConfigError, "First args must be a symbol like: :name or :account.name" unless args[0].is_a?(Symbol)

          # Construct our options
          options = { :method => args[0] }

          # If we have a second args that is not an hash maybe an header
          options[:header]  = args[1].is_a?(String) || args[1].is_a?(Symbol) ? args[1].to_s : nil

          args.each { |a| options.merge!(a) if a.is_a?(Hash)  }

          # Add some defaults
          options[:header]   ||= options[:method].to_s
          options[:sortable]   = options[:sortable].nil? ? true : options[:sortable]

          # Try to translate header
          options[:header] = @model.human_attribute_name(options[:header].to_s)

          # Reformat DataIndex
          # 
          # If we don't have nothing we use the method
          options[:dataIndex] ||= options[:method]

          data_indexes = Array(options[:dataIndex]).collect do |data_index|
            case data_index
              when String then data_index
              when Symbol
                if data_index.missing_methods.size == 1
                  options[:name] ||= "#{@model.table_name.singularize}[#{data_index}]"
                  data_index = "#{@model.table_name}.#{data_index}"
                else
                  columns = data_index.missing_methods
                  options[:name] ||= columns.at(0) + "[" + columns[1..-1].collect(&:to_s).join("][") + "]"
                  data_index = columns[0..-2].collect { |c| c.to_s.pluralize }.join(".") + "." + columns.at(-1).to_s
                end
            end
            data_index
          end

          options[:dataIndex] = data_indexes.compact.uniq.join(",")

          # Reformat mapping like a div id
          options[:mapping] ||= options[:name].sub(/\[/,"_").sub(/\]$/, "").sub(/\]\[/,"_")
          
          # Now is necessary for our columns an ID
          # TODO: check duplicates here
          options[:id] = options[:mapping]

          @data << options
        end

        # Return an array config for build an Ext.grid.ColumnModel() config
        def column_fields
          @data.map do |data|
            data.delete(:method)
            data.delete(:mapping)
            data
          end
        end

        # Return an array config for build an Ext.data.GroupingStore()
        def store_fields
          @data.map do |data|
            hash = { :name => data[:dataIndex], :mapping => data[:mapping] }
            hash.merge!(:type => data[:renderer]) if  data[:renderer] && [:date, :datetime, :time_to_date].include?(data[:renderer])
            hash
          end
        end

        # Return data for a custom collection for the ExtJS Ext.data.GroupingStore() json
        def store_data_from(collection)
          collection.map do |c|
            @data.dup.inject({ "id" => c.id }) do |options, data|
              options[data[:mapping]] = (c.instance_eval(data[:method].to_s) rescue I18n.t("padrino.admin.labels.not_found"))
              options
            end
          end
        end

        # Return a searched and paginated data collection for the ExtJS Ext.data.GroupingStore() json
        # You can pass options like:
        # 
        #   Examples
        #   
        #     store_data(params, :conditions => "found = 1")
        #     store_data(params, :include => :posts)
        # 
        def store_data(params={}, options={})
          # Some can tell me that this method made two identical queries one for count one for paginate.
          # We don't use the select count because in some circumstances require much time than select *.
          collection           = @model.all(options).ext_search(params)
          collection_count     = collection.length
          collection_paginated = collection.ext_paginate(params)
          { :results => store_data_from(collection_paginated), :count => collection_count }
        end

      end
    end
  end
end